{"ast":null,"code":"import { useEffect, useRef } from 'react';\nimport { useForm } from 'react-final-form';\nimport { useHistory } from 'react-router-dom';\nimport { useTranslate } from '../i18n';\n/**\n * Display a confirmation dialog if the form has unsaved changes.\n * - If the user confirms, the navigation continues and the changes are lost.\n * - If the user cancels, the navigation is reverted and the changes are kept.\n *\n * We can't use history.block() here because forms have routes, too (for\n * instance TabbedForm), and the confirm dialog would show up when navigating\n * inside the form. So instead of relying on route change detection, we rely\n * on unmount detection. The resulting UI isn't perfect, because when they\n * click the cancel button, users briefly see the page they asked before\n * seeing the form page again. But that's the best we can do.\n *\n * @see history.block()\n */\n\nvar useWarnWhenUnsavedChanges = function (enable) {\n  var form = useForm();\n  var history = useHistory();\n  var translate = useTranslate(); // Keep track of the current location inside the form (e.g. active tab)\n\n  var formLocation = useRef(history.location);\n  useEffect(function () {\n    formLocation.current = history.location;\n  }, [history.location]);\n  useEffect(function () {\n    if (!enable) {\n      window.sessionStorage.removeItem('unsavedChanges');\n      return;\n    } // on mount: apply unsaved changes\n\n\n    var unsavedChanges = JSON.parse(window.sessionStorage.getItem('unsavedChanges'));\n\n    if (unsavedChanges) {\n      Object.keys(unsavedChanges).forEach(function (key) {\n        return form.change(key, unsavedChanges[key]);\n      });\n      window.sessionStorage.removeItem('unsavedChanges');\n    } // on unmount : check and save unsaved changes, then cancel navigation\n\n\n    return function () {\n      var formState = form.getState();\n\n      if (formState.dirty && (!formState.submitSucceeded || formState.submitSucceeded && formState.dirtySinceLastSubmit)) {\n        if (!window.confirm(translate('ra.message.unsaved_changes'))) {\n          var dirtyFields = formState.submitSucceeded ? formState.dirtySinceLastSubmit : formState.dirtyFields;\n          var dirtyFieldValues = Object.keys(dirtyFields).reduce(function (acc, key) {\n            acc[key] = formState.values[key];\n            return acc;\n          }, {});\n          window.sessionStorage.setItem('unsavedChanges', JSON.stringify(dirtyFieldValues));\n          history.push(formLocation.current);\n        }\n      } else {\n        window.sessionStorage.removeItem('unsavedChanges');\n      }\n    };\n  }, [translate]); // eslint-disable-line react-hooks/exhaustive-deps\n};\n\nexport default useWarnWhenUnsavedChanges;","map":{"version":3,"sources":["/node_modules/ra-core/esm/form/useWarnWhenUnsavedChanges.js"],"names":["useEffect","useRef","useForm","useHistory","useTranslate","useWarnWhenUnsavedChanges","enable","form","history","translate","formLocation","location","current","window","sessionStorage","removeItem","unsavedChanges","JSON","parse","getItem","Object","keys","forEach","key","change","formState","getState","dirty","submitSucceeded","dirtySinceLastSubmit","confirm","dirtyFields","dirtyFieldValues","reduce","acc","values","setItem","stringify","push"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;AACA,SAASC,OAAT,QAAwB,kBAAxB;AACA,SAASC,UAAT,QAA2B,kBAA3B;AACA,SAASC,YAAT,QAA6B,SAA7B;AACA;;;;;;;;;;;;;;;AAcA,IAAIC,yBAAyB,GAAG,UAAUC,MAAV,EAAkB;AAC9C,MAAIC,IAAI,GAAGL,OAAO,EAAlB;AACA,MAAIM,OAAO,GAAGL,UAAU,EAAxB;AACA,MAAIM,SAAS,GAAGL,YAAY,EAA5B,CAH8C,CAI9C;;AACA,MAAIM,YAAY,GAAGT,MAAM,CAACO,OAAO,CAACG,QAAT,CAAzB;AACAX,EAAAA,SAAS,CAAC,YAAY;AAClBU,IAAAA,YAAY,CAACE,OAAb,GAAuBJ,OAAO,CAACG,QAA/B;AACH,GAFQ,EAEN,CAACH,OAAO,CAACG,QAAT,CAFM,CAAT;AAGAX,EAAAA,SAAS,CAAC,YAAY;AAClB,QAAI,CAACM,MAAL,EAAa;AACTO,MAAAA,MAAM,CAACC,cAAP,CAAsBC,UAAtB,CAAiC,gBAAjC;AACA;AACH,KAJiB,CAKlB;;;AACA,QAAIC,cAAc,GAAGC,IAAI,CAACC,KAAL,CAAWL,MAAM,CAACC,cAAP,CAAsBK,OAAtB,CAA8B,gBAA9B,CAAX,CAArB;;AACA,QAAIH,cAAJ,EAAoB;AAChBI,MAAAA,MAAM,CAACC,IAAP,CAAYL,cAAZ,EAA4BM,OAA5B,CAAoC,UAAUC,GAAV,EAAe;AAC/C,eAAOhB,IAAI,CAACiB,MAAL,CAAYD,GAAZ,EAAiBP,cAAc,CAACO,GAAD,CAA/B,CAAP;AACH,OAFD;AAGAV,MAAAA,MAAM,CAACC,cAAP,CAAsBC,UAAtB,CAAiC,gBAAjC;AACH,KAZiB,CAalB;;;AACA,WAAO,YAAY;AACf,UAAIU,SAAS,GAAGlB,IAAI,CAACmB,QAAL,EAAhB;;AACA,UAAID,SAAS,CAACE,KAAV,KACC,CAACF,SAAS,CAACG,eAAX,IACIH,SAAS,CAACG,eAAV,IACGH,SAAS,CAACI,oBAHlB,CAAJ,EAG8C;AAC1C,YAAI,CAAChB,MAAM,CAACiB,OAAP,CAAerB,SAAS,CAAC,4BAAD,CAAxB,CAAL,EAA8D;AAC1D,cAAIsB,WAAW,GAAGN,SAAS,CAACG,eAAV,GACZH,SAAS,CAACI,oBADE,GAEZJ,SAAS,CAACM,WAFhB;AAGA,cAAIC,gBAAgB,GAAGZ,MAAM,CAACC,IAAP,CAAYU,WAAZ,EAAyBE,MAAzB,CAAgC,UAAUC,GAAV,EAAeX,GAAf,EAAoB;AACvEW,YAAAA,GAAG,CAACX,GAAD,CAAH,GAAWE,SAAS,CAACU,MAAV,CAAiBZ,GAAjB,CAAX;AACA,mBAAOW,GAAP;AACH,WAHsB,EAGpB,EAHoB,CAAvB;AAIArB,UAAAA,MAAM,CAACC,cAAP,CAAsBsB,OAAtB,CAA8B,gBAA9B,EAAgDnB,IAAI,CAACoB,SAAL,CAAeL,gBAAf,CAAhD;AACAxB,UAAAA,OAAO,CAAC8B,IAAR,CAAa5B,YAAY,CAACE,OAA1B;AACH;AACJ,OAfD,MAgBK;AACDC,QAAAA,MAAM,CAACC,cAAP,CAAsBC,UAAtB,CAAiC,gBAAjC;AACH;AACJ,KArBD;AAsBH,GApCQ,EAoCN,CAACN,SAAD,CApCM,CAAT,CAT8C,CA6C7B;AACpB,CA9CD;;AA+CA,eAAeJ,yBAAf","sourcesContent":["import { useEffect, useRef } from 'react';\nimport { useForm } from 'react-final-form';\nimport { useHistory } from 'react-router-dom';\nimport { useTranslate } from '../i18n';\n/**\n * Display a confirmation dialog if the form has unsaved changes.\n * - If the user confirms, the navigation continues and the changes are lost.\n * - If the user cancels, the navigation is reverted and the changes are kept.\n *\n * We can't use history.block() here because forms have routes, too (for\n * instance TabbedForm), and the confirm dialog would show up when navigating\n * inside the form. So instead of relying on route change detection, we rely\n * on unmount detection. The resulting UI isn't perfect, because when they\n * click the cancel button, users briefly see the page they asked before\n * seeing the form page again. But that's the best we can do.\n *\n * @see history.block()\n */\nvar useWarnWhenUnsavedChanges = function (enable) {\n    var form = useForm();\n    var history = useHistory();\n    var translate = useTranslate();\n    // Keep track of the current location inside the form (e.g. active tab)\n    var formLocation = useRef(history.location);\n    useEffect(function () {\n        formLocation.current = history.location;\n    }, [history.location]);\n    useEffect(function () {\n        if (!enable) {\n            window.sessionStorage.removeItem('unsavedChanges');\n            return;\n        }\n        // on mount: apply unsaved changes\n        var unsavedChanges = JSON.parse(window.sessionStorage.getItem('unsavedChanges'));\n        if (unsavedChanges) {\n            Object.keys(unsavedChanges).forEach(function (key) {\n                return form.change(key, unsavedChanges[key]);\n            });\n            window.sessionStorage.removeItem('unsavedChanges');\n        }\n        // on unmount : check and save unsaved changes, then cancel navigation\n        return function () {\n            var formState = form.getState();\n            if (formState.dirty &&\n                (!formState.submitSucceeded ||\n                    (formState.submitSucceeded &&\n                        formState.dirtySinceLastSubmit))) {\n                if (!window.confirm(translate('ra.message.unsaved_changes'))) {\n                    var dirtyFields = formState.submitSucceeded\n                        ? formState.dirtySinceLastSubmit\n                        : formState.dirtyFields;\n                    var dirtyFieldValues = Object.keys(dirtyFields).reduce(function (acc, key) {\n                        acc[key] = formState.values[key];\n                        return acc;\n                    }, {});\n                    window.sessionStorage.setItem('unsavedChanges', JSON.stringify(dirtyFieldValues));\n                    history.push(formLocation.current);\n                }\n            }\n            else {\n                window.sessionStorage.removeItem('unsavedChanges');\n            }\n        };\n    }, [translate]); // eslint-disable-line react-hooks/exhaustive-deps\n};\nexport default useWarnWhenUnsavedChanges;\n"]},"metadata":{},"sourceType":"module"}