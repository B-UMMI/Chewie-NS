{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n} //      \n\n\nfunction moveFieldState(state, source, destKey, oldState) {\n  if (oldState === void 0) {\n    oldState = state;\n  }\n\n  delete state.fields[source.name];\n  state.fields[destKey] = _extends({}, source, {\n    name: destKey,\n    // prevent functions from being overwritten\n    // if the state.fields[destKey] does not exist, it will be created\n    // when that field gets registered, with its own change/blur/focus callbacks\n    change: oldState.fields[destKey] && oldState.fields[destKey].change,\n    blur: oldState.fields[destKey] && oldState.fields[destKey].blur,\n    focus: oldState.fields[destKey] && oldState.fields[destKey].focus,\n    lastFieldState: undefined // clearing lastFieldState forces renotification\n\n  });\n\n  if (!state.fields[destKey].change) {\n    delete state.fields[destKey].change;\n  }\n\n  if (!state.fields[destKey].blur) {\n    delete state.fields[destKey].blur;\n  }\n\n  if (!state.fields[destKey].focus) {\n    delete state.fields[destKey].focus;\n  }\n} //      \n// From MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n\n\nvar escapeRegexTokens = function escapeRegexTokens(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}; // $& means the whole matched string\n\n\nvar insert = function insert(_ref, state, _ref2) {\n  var name = _ref[0],\n      index = _ref[1],\n      value = _ref[2];\n  var changeValue = _ref2.changeValue,\n      resetFieldState = _ref2.resetFieldState;\n  changeValue(state, name, function (array) {\n    var copy = [].concat(array || []);\n    copy.splice(index, 0, value);\n    return copy;\n  });\n\n  var backup = _extends({}, state.fields); // now we have increment any higher indexes\n\n\n  var pattern = new RegExp(\"^\" + escapeRegexTokens(name) + \"\\\\[(\\\\d+)\\\\](.*)\"); // we need to increment high indices first so\n  // lower indices won't overlap\n\n  Object.keys(state.fields).sort().reverse().forEach(function (key) {\n    var tokens = pattern.exec(key);\n\n    if (tokens) {\n      var fieldIndex = Number(tokens[1]);\n\n      if (fieldIndex >= index) {\n        // inc index one higher\n        var incrementedKey = name + \"[\" + (fieldIndex + 1) + \"]\" + tokens[2];\n        moveFieldState(state, backup[key], incrementedKey);\n      }\n    }\n  });\n}; //      \n\n\nvar concat = function concat(_ref, state, _ref2) {\n  var name = _ref[0],\n      value = _ref[1];\n  var changeValue = _ref2.changeValue;\n  changeValue(state, name, function (array) {\n    return array ? [].concat(array, value) : value;\n  });\n}; //      \n\n\nfunction moveFields(name, matchPrefix, destIndex, state) {\n  Object.keys(state.fields).forEach(function (key) {\n    if (key.substring(0, matchPrefix.length) === matchPrefix) {\n      var suffix = key.substring(matchPrefix.length);\n      var destKey = name + \"[\" + destIndex + \"]\" + suffix;\n      moveFieldState(state, state.fields[key], destKey);\n    }\n  });\n} //      \n\n\nfunction restoreFunctions(state, backupState) {\n  Object.keys(state.fields).forEach(function (key) {\n    state.fields[key] = _extends({}, state.fields[key], {\n      change: state.fields[key].change || backupState.fields[key] && backupState.fields[key].change,\n      blur: state.fields[key].blur || backupState.fields[key] && backupState.fields[key].blur,\n      focus: state.fields[key].focus || backupState.fields[key] && backupState.fields[key].focus\n    });\n\n    if (!state.fields[key].change) {\n      delete state.fields[key].change;\n    }\n\n    if (!state.fields[key].blur) {\n      delete state.fields[key].blur;\n    }\n\n    if (!state.fields[key].focus) {\n      delete state.fields[key].focus;\n    }\n  });\n}\n\nvar TMP = 'tmp';\n\nvar move = function move(_ref, state, _ref2) {\n  var name = _ref[0],\n      from = _ref[1],\n      to = _ref[2];\n  var changeValue = _ref2.changeValue;\n\n  if (from === to) {\n    return;\n  }\n\n  changeValue(state, name, function (array) {\n    var copy = [].concat(array || []);\n    var value = copy[from];\n    copy.splice(from, 1);\n    copy.splice(to, 0, value);\n    return copy;\n  }); //make a copy of a state for further functions restore\n\n  var backupState = _extends({}, state, {\n    fields: _extends({}, state.fields) // move this row to tmp index\n\n  });\n\n  var fromPrefix = name + \"[\" + from + \"]\";\n  moveFields(name, fromPrefix, TMP, state);\n\n  if (from < to) {\n    // moving to a higher index\n    // decrement all indices between from and to\n    for (var i = from + 1; i <= to; i++) {\n      var innerFromPrefix = name + \"[\" + i + \"]\";\n      moveFields(name, innerFromPrefix, \"\" + (i - 1), state);\n    }\n  } else {\n    // moving to a lower index\n    // increment all indices between to and from\n    for (var _i = from - 1; _i >= to; _i--) {\n      var _innerFromPrefix = name + \"[\" + _i + \"]\";\n\n      moveFields(name, _innerFromPrefix, \"\" + (_i + 1), state);\n    }\n  } // move from tmp index to destination\n\n\n  var tmpPrefix = name + \"[\" + TMP + \"]\";\n  moveFields(name, tmpPrefix, to, state);\n  restoreFunctions(state, backupState);\n}; //      \n\n\nvar pop = function pop(_ref, state, _ref2) {\n  var name = _ref[0];\n  var changeValue = _ref2.changeValue;\n  var result;\n  var removedIndex;\n  changeValue(state, name, function (array) {\n    if (array) {\n      if (!array.length) {\n        return [];\n      }\n\n      removedIndex = array.length - 1;\n      result = array[removedIndex];\n      return array.slice(0, removedIndex);\n    }\n  }); // now we have to remove any subfields for our index,\n\n  if (removedIndex !== undefined) {\n    var pattern = new RegExp(\"^\" + escapeRegexTokens(name) + \"\\\\[\" + removedIndex + \"].*\");\n    Object.keys(state.fields).forEach(function (key) {\n      if (pattern.test(key)) {\n        delete state.fields[key];\n      }\n    });\n  }\n\n  return result;\n}; //      \n\n\nvar push = function push(_ref, state, _ref2) {\n  var name = _ref[0],\n      value = _ref[1];\n  var changeValue = _ref2.changeValue;\n  changeValue(state, name, function (array) {\n    return array ? [].concat(array, [value]) : [value];\n  });\n};\n\nvar remove = function remove(_ref, state, _ref2) {\n  var name = _ref[0],\n      index = _ref[1];\n  var changeValue = _ref2.changeValue,\n      renameField = _ref2.renameField;\n  var returnValue;\n  changeValue(state, name, function (array) {\n    var copy = [].concat(array || []);\n    returnValue = copy[index];\n    copy.splice(index, 1);\n    return copy;\n  }); // now we have to remove any subfields for our index,\n  // and decrement all higher indexes.\n\n  var pattern = new RegExp(\"^\" + escapeRegexTokens(name) + \"\\\\[(\\\\d+)\\\\](.*)\");\n\n  var backup = _extends({}, state, {\n    fields: _extends({}, state.fields)\n  });\n\n  Object.keys(state.fields).forEach(function (key) {\n    var tokens = pattern.exec(key);\n\n    if (tokens) {\n      var fieldIndex = Number(tokens[1]);\n\n      if (fieldIndex === index) {\n        // delete any subfields for this array item\n        delete state.fields[key];\n      } else if (fieldIndex > index) {\n        // shift all higher ones down\n        delete state.fields[key];\n        var decrementedKey = name + \"[\" + (fieldIndex - 1) + \"]\" + tokens[2];\n\n        if (backup.fields[decrementedKey]) {\n          moveFieldState(state, backup.fields[key], decrementedKey, backup);\n        } else {\n          // take care of setting the correct change, blur, focus, validators on new field\n          renameField(state, key, decrementedKey);\n        }\n      }\n    }\n  });\n  return returnValue;\n};\n\nvar countBelow = function countBelow(array, value) {\n  return array.reduce(function (count, item) {\n    return item < value ? count + 1 : count;\n  }, 0);\n};\n\nvar removeBatch = function removeBatch(_ref, state, _ref2) {\n  var name = _ref[0],\n      indexes = _ref[1];\n  var changeValue = _ref2.changeValue;\n  var sortedIndexes = [].concat(indexes);\n  sortedIndexes.sort(); // remove duplicates\n\n  for (var i = 0; i < sortedIndexes.length; i++) {\n    if (i > 0 && sortedIndexes[i] === sortedIndexes[i - 1]) {\n      sortedIndexes.splice(i--, 1);\n    }\n  }\n\n  var returnValue = [];\n  changeValue(state, name, function (array) {\n    // use original order of indexes for return value\n    returnValue = indexes.map(function (index) {\n      return array && array[index];\n    });\n\n    if (!array || !sortedIndexes.length) {\n      return array;\n    }\n\n    var copy = [].concat(array);\n    var removed = [];\n    sortedIndexes.forEach(function (index) {\n      copy.splice(index - removed.length, 1);\n      removed.push(array && array[index]);\n    });\n    return copy;\n  }); // now we have to remove any subfields for our indexes,\n  // and decrement all higher indexes.\n\n  var pattern = new RegExp(\"^\" + escapeRegexTokens(name) + \"\\\\[(\\\\d+)\\\\](.*)\");\n\n  var newState = _extends({}, state, {\n    fields: {}\n  });\n\n  Object.keys(state.fields).forEach(function (key) {\n    var tokens = pattern.exec(key);\n\n    if (tokens) {\n      var fieldIndex = Number(tokens[1]);\n\n      if (!~sortedIndexes.indexOf(fieldIndex)) {\n        // not one of the removed indexes\n        // shift all higher ones down\n        var decrementedKey = name + \"[\" + (fieldIndex - countBelow(sortedIndexes, fieldIndex)) + \"]\" + tokens[2];\n        moveFieldState(newState, state.fields[key], decrementedKey, state);\n      }\n    } else {\n      newState.fields[key] = state.fields[key];\n    }\n  });\n  state.fields = newState.fields;\n  return returnValue;\n}; //      \n\n\nvar shift = function shift(_ref, state, tools) {\n  var name = _ref[0];\n  return remove([name, 0], state, tools);\n};\n\nvar TMP$1 = 'tmp';\n\nvar swap = function swap(_ref, state, _ref2) {\n  var name = _ref[0],\n      indexA = _ref[1],\n      indexB = _ref[2];\n  var changeValue = _ref2.changeValue;\n\n  if (indexA === indexB) {\n    return;\n  }\n\n  changeValue(state, name, function (array) {\n    var copy = [].concat(array || []);\n    var a = copy[indexA];\n    copy[indexA] = copy[indexB];\n    copy[indexB] = a;\n    return copy;\n  }); //make a copy of a state for further functions restore\n\n  var backupState = _extends({}, state, {\n    fields: _extends({}, state.fields) // swap all field state that begin with \"name[indexA]\" with that under \"name[indexB]\"\n\n  });\n\n  var aPrefix = name + \"[\" + indexA + \"]\";\n  var bPrefix = name + \"[\" + indexB + \"]\";\n  var tmpPrefix = name + \"[\" + TMP$1 + \"]\";\n  moveFields(name, aPrefix, TMP$1, state);\n  moveFields(name, bPrefix, indexA, state);\n  moveFields(name, tmpPrefix, indexB, state);\n  restoreFunctions(state, backupState);\n}; //      \n\n\nvar unshift = function unshift(_ref, state, tools) {\n  var name = _ref[0],\n      value = _ref[1];\n  return insert([name, 0, value], state, tools);\n}; //      \n\n\nvar update = function update(_ref, state, _ref2) {\n  var name = _ref[0],\n      index = _ref[1],\n      value = _ref[2];\n  var changeValue = _ref2.changeValue;\n  changeValue(state, name, function (array) {\n    var copy = [].concat(array || []);\n    copy.splice(index, 1, value);\n    return copy;\n  });\n}; //      \n\n\nvar mutators = {\n  insert: insert,\n  concat: concat,\n  move: move,\n  pop: pop,\n  push: push,\n  remove: remove,\n  removeBatch: removeBatch,\n  shift: shift,\n  swap: swap,\n  unshift: unshift,\n  update: update\n};\nexport default mutators;","map":{"version":3,"sources":["/node_modules/final-form-arrays/dist/final-form-arrays.es.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","moveFieldState","state","destKey","oldState","fields","name","change","blur","focus","lastFieldState","undefined","escapeRegexTokens","string","replace","insert","_ref","_ref2","index","value","changeValue","resetFieldState","array","copy","concat","splice","backup","pattern","RegExp","keys","sort","reverse","forEach","tokens","exec","fieldIndex","Number","incrementedKey","moveFields","matchPrefix","destIndex","substring","suffix","restoreFunctions","backupState","TMP","move","from","to","fromPrefix","innerFromPrefix","_i","_innerFromPrefix","tmpPrefix","pop","result","removedIndex","slice","test","push","remove","renameField","returnValue","decrementedKey","countBelow","reduce","count","item","removeBatch","indexes","sortedIndexes","map","removed","newState","indexOf","shift","tools","TMP$1","swap","indexA","indexB","a","aPrefix","bPrefix","unshift","update","mutators"],"mappings":"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","sourcesContent":["function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n//      \nfunction moveFieldState(state, source, destKey, oldState) {\n  if (oldState === void 0) {\n    oldState = state;\n  }\n\n  delete state.fields[source.name];\n  state.fields[destKey] = _extends({}, source, {\n    name: destKey,\n    // prevent functions from being overwritten\n    // if the state.fields[destKey] does not exist, it will be created\n    // when that field gets registered, with its own change/blur/focus callbacks\n    change: oldState.fields[destKey] && oldState.fields[destKey].change,\n    blur: oldState.fields[destKey] && oldState.fields[destKey].blur,\n    focus: oldState.fields[destKey] && oldState.fields[destKey].focus,\n    lastFieldState: undefined // clearing lastFieldState forces renotification\n\n  });\n\n  if (!state.fields[destKey].change) {\n    delete state.fields[destKey].change;\n  }\n\n  if (!state.fields[destKey].blur) {\n    delete state.fields[destKey].blur;\n  }\n\n  if (!state.fields[destKey].focus) {\n    delete state.fields[destKey].focus;\n  }\n}\n\n//      \n// From MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\nvar escapeRegexTokens = function escapeRegexTokens(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}; // $& means the whole matched string\n\nvar insert = function insert(_ref, state, _ref2) {\n  var name = _ref[0],\n      index = _ref[1],\n      value = _ref[2];\n  var changeValue = _ref2.changeValue,\n      resetFieldState = _ref2.resetFieldState;\n  changeValue(state, name, function (array) {\n    var copy = [].concat(array || []);\n    copy.splice(index, 0, value);\n    return copy;\n  });\n\n  var backup = _extends({}, state.fields); // now we have increment any higher indexes\n\n\n  var pattern = new RegExp(\"^\" + escapeRegexTokens(name) + \"\\\\[(\\\\d+)\\\\](.*)\"); // we need to increment high indices first so\n  // lower indices won't overlap\n\n  Object.keys(state.fields).sort().reverse().forEach(function (key) {\n    var tokens = pattern.exec(key);\n\n    if (tokens) {\n      var fieldIndex = Number(tokens[1]);\n\n      if (fieldIndex >= index) {\n        // inc index one higher\n        var incrementedKey = name + \"[\" + (fieldIndex + 1) + \"]\" + tokens[2];\n        moveFieldState(state, backup[key], incrementedKey);\n      }\n    }\n  });\n};\n\n//      \nvar concat = function concat(_ref, state, _ref2) {\n  var name = _ref[0],\n      value = _ref[1];\n  var changeValue = _ref2.changeValue;\n  changeValue(state, name, function (array) {\n    return array ? [].concat(array, value) : value;\n  });\n};\n\n//      \n\nfunction moveFields(name, matchPrefix, destIndex, state) {\n  Object.keys(state.fields).forEach(function (key) {\n    if (key.substring(0, matchPrefix.length) === matchPrefix) {\n      var suffix = key.substring(matchPrefix.length);\n      var destKey = name + \"[\" + destIndex + \"]\" + suffix;\n      moveFieldState(state, state.fields[key], destKey);\n    }\n  });\n}\n\n//      \nfunction restoreFunctions(state, backupState) {\n  Object.keys(state.fields).forEach(function (key) {\n    state.fields[key] = _extends({}, state.fields[key], {\n      change: state.fields[key].change || backupState.fields[key] && backupState.fields[key].change,\n      blur: state.fields[key].blur || backupState.fields[key] && backupState.fields[key].blur,\n      focus: state.fields[key].focus || backupState.fields[key] && backupState.fields[key].focus\n    });\n\n    if (!state.fields[key].change) {\n      delete state.fields[key].change;\n    }\n\n    if (!state.fields[key].blur) {\n      delete state.fields[key].blur;\n    }\n\n    if (!state.fields[key].focus) {\n      delete state.fields[key].focus;\n    }\n  });\n}\n\nvar TMP = 'tmp';\n\nvar move = function move(_ref, state, _ref2) {\n  var name = _ref[0],\n      from = _ref[1],\n      to = _ref[2];\n  var changeValue = _ref2.changeValue;\n\n  if (from === to) {\n    return;\n  }\n\n  changeValue(state, name, function (array) {\n    var copy = [].concat(array || []);\n    var value = copy[from];\n    copy.splice(from, 1);\n    copy.splice(to, 0, value);\n    return copy;\n  }); //make a copy of a state for further functions restore\n\n  var backupState = _extends({}, state, {\n    fields: _extends({}, state.fields) // move this row to tmp index\n\n  });\n\n  var fromPrefix = name + \"[\" + from + \"]\";\n  moveFields(name, fromPrefix, TMP, state);\n\n  if (from < to) {\n    // moving to a higher index\n    // decrement all indices between from and to\n    for (var i = from + 1; i <= to; i++) {\n      var innerFromPrefix = name + \"[\" + i + \"]\";\n      moveFields(name, innerFromPrefix, \"\" + (i - 1), state);\n    }\n  } else {\n    // moving to a lower index\n    // increment all indices between to and from\n    for (var _i = from - 1; _i >= to; _i--) {\n      var _innerFromPrefix = name + \"[\" + _i + \"]\";\n\n      moveFields(name, _innerFromPrefix, \"\" + (_i + 1), state);\n    }\n  } // move from tmp index to destination\n\n\n  var tmpPrefix = name + \"[\" + TMP + \"]\";\n  moveFields(name, tmpPrefix, to, state);\n  restoreFunctions(state, backupState);\n};\n\n//      \n\nvar pop = function pop(_ref, state, _ref2) {\n  var name = _ref[0];\n  var changeValue = _ref2.changeValue;\n  var result;\n  var removedIndex;\n  changeValue(state, name, function (array) {\n    if (array) {\n      if (!array.length) {\n        return [];\n      }\n\n      removedIndex = array.length - 1;\n      result = array[removedIndex];\n      return array.slice(0, removedIndex);\n    }\n  }); // now we have to remove any subfields for our index,\n\n  if (removedIndex !== undefined) {\n    var pattern = new RegExp(\"^\" + escapeRegexTokens(name) + \"\\\\[\" + removedIndex + \"].*\");\n    Object.keys(state.fields).forEach(function (key) {\n      if (pattern.test(key)) {\n        delete state.fields[key];\n      }\n    });\n  }\n\n  return result;\n};\n\n//      \nvar push = function push(_ref, state, _ref2) {\n  var name = _ref[0],\n      value = _ref[1];\n  var changeValue = _ref2.changeValue;\n  changeValue(state, name, function (array) {\n    return array ? [].concat(array, [value]) : [value];\n  });\n};\n\nvar remove = function remove(_ref, state, _ref2) {\n  var name = _ref[0],\n      index = _ref[1];\n  var changeValue = _ref2.changeValue,\n      renameField = _ref2.renameField;\n  var returnValue;\n  changeValue(state, name, function (array) {\n    var copy = [].concat(array || []);\n    returnValue = copy[index];\n    copy.splice(index, 1);\n    return copy;\n  }); // now we have to remove any subfields for our index,\n  // and decrement all higher indexes.\n\n  var pattern = new RegExp(\"^\" + escapeRegexTokens(name) + \"\\\\[(\\\\d+)\\\\](.*)\");\n\n  var backup = _extends({}, state, {\n    fields: _extends({}, state.fields)\n  });\n\n  Object.keys(state.fields).forEach(function (key) {\n    var tokens = pattern.exec(key);\n\n    if (tokens) {\n      var fieldIndex = Number(tokens[1]);\n\n      if (fieldIndex === index) {\n        // delete any subfields for this array item\n        delete state.fields[key];\n      } else if (fieldIndex > index) {\n        // shift all higher ones down\n        delete state.fields[key];\n        var decrementedKey = name + \"[\" + (fieldIndex - 1) + \"]\" + tokens[2];\n\n        if (backup.fields[decrementedKey]) {\n          moveFieldState(state, backup.fields[key], decrementedKey, backup);\n        } else {\n          // take care of setting the correct change, blur, focus, validators on new field\n          renameField(state, key, decrementedKey);\n        }\n      }\n    }\n  });\n  return returnValue;\n};\n\nvar countBelow = function countBelow(array, value) {\n  return array.reduce(function (count, item) {\n    return item < value ? count + 1 : count;\n  }, 0);\n};\n\nvar removeBatch = function removeBatch(_ref, state, _ref2) {\n  var name = _ref[0],\n      indexes = _ref[1];\n  var changeValue = _ref2.changeValue;\n  var sortedIndexes = [].concat(indexes);\n  sortedIndexes.sort(); // remove duplicates\n\n  for (var i = 0; i < sortedIndexes.length; i++) {\n    if (i > 0 && sortedIndexes[i] === sortedIndexes[i - 1]) {\n      sortedIndexes.splice(i--, 1);\n    }\n  }\n\n  var returnValue = [];\n  changeValue(state, name, function (array) {\n    // use original order of indexes for return value\n    returnValue = indexes.map(function (index) {\n      return array && array[index];\n    });\n\n    if (!array || !sortedIndexes.length) {\n      return array;\n    }\n\n    var copy = [].concat(array);\n    var removed = [];\n    sortedIndexes.forEach(function (index) {\n      copy.splice(index - removed.length, 1);\n      removed.push(array && array[index]);\n    });\n    return copy;\n  }); // now we have to remove any subfields for our indexes,\n  // and decrement all higher indexes.\n\n  var pattern = new RegExp(\"^\" + escapeRegexTokens(name) + \"\\\\[(\\\\d+)\\\\](.*)\");\n\n  var newState = _extends({}, state, {\n    fields: {}\n  });\n\n  Object.keys(state.fields).forEach(function (key) {\n    var tokens = pattern.exec(key);\n\n    if (tokens) {\n      var fieldIndex = Number(tokens[1]);\n\n      if (!~sortedIndexes.indexOf(fieldIndex)) {\n        // not one of the removed indexes\n        // shift all higher ones down\n        var decrementedKey = name + \"[\" + (fieldIndex - countBelow(sortedIndexes, fieldIndex)) + \"]\" + tokens[2];\n        moveFieldState(newState, state.fields[key], decrementedKey, state);\n      }\n    } else {\n      newState.fields[key] = state.fields[key];\n    }\n  });\n  state.fields = newState.fields;\n  return returnValue;\n};\n\n//      \n\nvar shift = function shift(_ref, state, tools) {\n  var name = _ref[0];\n  return remove([name, 0], state, tools);\n};\n\nvar TMP$1 = 'tmp';\n\nvar swap = function swap(_ref, state, _ref2) {\n  var name = _ref[0],\n      indexA = _ref[1],\n      indexB = _ref[2];\n  var changeValue = _ref2.changeValue;\n\n  if (indexA === indexB) {\n    return;\n  }\n\n  changeValue(state, name, function (array) {\n    var copy = [].concat(array || []);\n    var a = copy[indexA];\n    copy[indexA] = copy[indexB];\n    copy[indexB] = a;\n    return copy;\n  }); //make a copy of a state for further functions restore\n\n  var backupState = _extends({}, state, {\n    fields: _extends({}, state.fields) // swap all field state that begin with \"name[indexA]\" with that under \"name[indexB]\"\n\n  });\n\n  var aPrefix = name + \"[\" + indexA + \"]\";\n  var bPrefix = name + \"[\" + indexB + \"]\";\n  var tmpPrefix = name + \"[\" + TMP$1 + \"]\";\n  moveFields(name, aPrefix, TMP$1, state);\n  moveFields(name, bPrefix, indexA, state);\n  moveFields(name, tmpPrefix, indexB, state);\n  restoreFunctions(state, backupState);\n};\n\n//      \n\nvar unshift = function unshift(_ref, state, tools) {\n  var name = _ref[0],\n      value = _ref[1];\n  return insert([name, 0, value], state, tools);\n};\n\n//      \nvar update = function update(_ref, state, _ref2) {\n  var name = _ref[0],\n      index = _ref[1],\n      value = _ref[2];\n  var changeValue = _ref2.changeValue;\n  changeValue(state, name, function (array) {\n    var copy = [].concat(array || []);\n    copy.splice(index, 1, value);\n    return copy;\n  });\n};\n\n//      \nvar mutators = {\n  insert: insert,\n  concat: concat,\n  move: move,\n  pop: pop,\n  push: push,\n  remove: remove,\n  removeBatch: removeBatch,\n  shift: shift,\n  swap: swap,\n  unshift: unshift,\n  update: update\n};\n\nexport default mutators;\n"]},"metadata":{},"sourceType":"module"}