{"ast":null,"code":"//     (c) 2012-2018 Airbnb, Inc.\n//\n//     polyglot.js may be freely distributed under the terms of the BSD\n//     license. For all licensing information, details, and documention:\n//     http://airbnb.github.com/polyglot.js\n//\n//\n// Polyglot.js is an I18n helper library written in JavaScript, made to\n// work both in the browser and in Node. It provides a simple solution for\n// interpolation and pluralization, based off of Airbnb's\n// experience adding I18n functionality to its Backbone.js and Node apps.\n//\n// Polylglot is agnostic to your translation backend. It doesn't perform any\n// translation; it simply gives you a way to manage translated phrases from\n// your client- or server-side JavaScript application.\n//\n'use strict';\n\nvar forEach = require('for-each');\n\nvar warning = require('warning');\n\nvar has = require('has');\n\nvar trim = require('string.prototype.trim');\n\nvar warn = function warn(message) {\n  warning(false, message);\n};\n\nvar replace = String.prototype.replace;\nvar split = String.prototype.split; // #### Pluralization methods\n// The string that separates the different phrase possibilities.\n\nvar delimiter = '||||';\n\nvar russianPluralGroups = function (n) {\n  var lastTwo = n % 100;\n  var end = lastTwo % 10;\n\n  if (lastTwo !== 11 && end === 1) {\n    return 0;\n  }\n\n  if (2 <= end && end <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {\n    return 1;\n  }\n\n  return 2;\n};\n\nvar defaultPluralRules = {\n  // Mapping from pluralization group plural logic.\n  pluralTypes: {\n    arabic: function (n) {\n      // http://www.arabeyes.org/Plural_Forms\n      if (n < 3) {\n        return n;\n      }\n\n      var lastTwo = n % 100;\n      if (lastTwo >= 3 && lastTwo <= 10) return 3;\n      return lastTwo >= 11 ? 4 : 5;\n    },\n    bosnian_serbian: russianPluralGroups,\n    chinese: function () {\n      return 0;\n    },\n    croatian: russianPluralGroups,\n    french: function (n) {\n      return n > 1 ? 1 : 0;\n    },\n    german: function (n) {\n      return n !== 1 ? 1 : 0;\n    },\n    russian: russianPluralGroups,\n    lithuanian: function (n) {\n      if (n % 10 === 1 && n % 100 !== 11) {\n        return 0;\n      }\n\n      return n % 10 >= 2 && n % 10 <= 9 && (n % 100 < 11 || n % 100 > 19) ? 1 : 2;\n    },\n    czech: function (n) {\n      if (n === 1) {\n        return 0;\n      }\n\n      return n >= 2 && n <= 4 ? 1 : 2;\n    },\n    polish: function (n) {\n      if (n === 1) {\n        return 0;\n      }\n\n      var end = n % 10;\n      return 2 <= end && end <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    icelandic: function (n) {\n      return n % 10 !== 1 || n % 100 === 11 ? 1 : 0;\n    },\n    slovenian: function (n) {\n      var lastTwo = n % 100;\n\n      if (lastTwo === 1) {\n        return 0;\n      }\n\n      if (lastTwo === 2) {\n        return 1;\n      }\n\n      if (lastTwo === 3 || lastTwo === 4) {\n        return 2;\n      }\n\n      return 3;\n    }\n  },\n  // Mapping from pluralization group to individual language codes/locales.\n  // Will look up based on exact match, if not found and it's a locale will parse the locale\n  // for language code, and if that does not exist will default to 'en'\n  pluralTypeToLanguages: {\n    arabic: ['ar'],\n    bosnian_serbian: ['bs-Latn-BA', 'bs-Cyrl-BA', 'srl-RS', 'sr-RS'],\n    chinese: ['id', 'id-ID', 'ja', 'ko', 'ko-KR', 'lo', 'ms', 'th', 'th-TH', 'zh'],\n    croatian: ['hr', 'hr-HR'],\n    german: ['fa', 'da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hi-IN', 'hu', 'hu-HU', 'it', 'nl', 'no', 'pt', 'sv', 'tr'],\n    french: ['fr', 'tl', 'pt-br'],\n    russian: ['ru', 'ru-RU'],\n    lithuanian: ['lt'],\n    czech: ['cs', 'cs-CZ', 'sk'],\n    polish: ['pl'],\n    icelandic: ['is'],\n    slovenian: ['sl-SL']\n  }\n};\n\nfunction langToTypeMap(mapping) {\n  var ret = {};\n  forEach(mapping, function (langs, type) {\n    forEach(langs, function (lang) {\n      ret[lang] = type;\n    });\n  });\n  return ret;\n}\n\nfunction pluralTypeName(pluralRules, locale) {\n  var langToPluralType = langToTypeMap(pluralRules.pluralTypeToLanguages);\n  return langToPluralType[locale] || langToPluralType[split.call(locale, /-/, 1)[0]] || langToPluralType.en;\n}\n\nfunction pluralTypeIndex(pluralRules, locale, count) {\n  return pluralRules.pluralTypes[pluralTypeName(pluralRules, locale)](count);\n}\n\nfunction escape(token) {\n  return token.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction constructTokenRegex(opts) {\n  var prefix = opts && opts.prefix || '%{';\n  var suffix = opts && opts.suffix || '}';\n\n  if (prefix === delimiter || suffix === delimiter) {\n    throw new RangeError('\"' + delimiter + '\" token is reserved for pluralization');\n  }\n\n  return new RegExp(escape(prefix) + '(.*?)' + escape(suffix), 'g');\n}\n\nvar defaultTokenRegex = /%\\{(.*?)\\}/g; // ### transformPhrase(phrase, substitutions, locale)\n//\n// Takes a phrase string and transforms it by choosing the correct\n// plural form and interpolating it.\n//\n//     transformPhrase('Hello, %{name}!', {name: 'Spike'});\n//     // \"Hello, Spike!\"\n//\n// The correct plural form is selected if substitutions.smart_count\n// is set. You can pass in a number instead of an Object as `substitutions`\n// as a shortcut for `smart_count`.\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 1}, 'en');\n//     // \"1 new message\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 2}, 'en');\n//     // \"2 new messages\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', 5, 'en');\n//     // \"5 new messages\"\n//\n// You should pass in a third argument, the locale, to specify the correct plural type.\n// It defaults to `'en'` with 2 plural forms.\n\nfunction transformPhrase(phrase, substitutions, locale, tokenRegex, pluralRules) {\n  if (typeof phrase !== 'string') {\n    throw new TypeError('Polyglot.transformPhrase expects argument #1 to be string');\n  }\n\n  if (substitutions == null) {\n    return phrase;\n  }\n\n  var result = phrase;\n  var interpolationRegex = tokenRegex || defaultTokenRegex;\n  var pluralRulesOrDefault = pluralRules || defaultPluralRules; // allow number as a pluralization shortcut\n\n  var options = typeof substitutions === 'number' ? {\n    smart_count: substitutions\n  } : substitutions; // Select plural form: based on a phrase text that contains `n`\n  // plural forms separated by `delimiter`, a `locale`, and a `substitutions.smart_count`,\n  // choose the correct plural form. This is only done if `count` is set.\n\n  if (options.smart_count != null && result) {\n    var texts = split.call(result, delimiter);\n    result = trim(texts[pluralTypeIndex(pluralRulesOrDefault, locale || 'en', options.smart_count)] || texts[0]);\n  } // Interpolate: Creates a `RegExp` object for each interpolation placeholder.\n\n\n  result = replace.call(result, interpolationRegex, function (expression, argument) {\n    if (!has(options, argument) || options[argument] == null) {\n      return expression;\n    }\n\n    return options[argument];\n  });\n  return result;\n} // ### Polyglot class constructor\n\n\nfunction Polyglot(options) {\n  var opts = options || {};\n  this.phrases = {};\n  this.extend(opts.phrases || {});\n  this.currentLocale = opts.locale || 'en';\n  var allowMissing = opts.allowMissing ? transformPhrase : null;\n  this.onMissingKey = typeof opts.onMissingKey === 'function' ? opts.onMissingKey : allowMissing;\n  this.warn = opts.warn || warn;\n  this.tokenRegex = constructTokenRegex(opts.interpolation);\n  this.pluralRules = opts.pluralRules || defaultPluralRules;\n} // ### polyglot.locale([locale])\n//\n// Get or set locale. Internally, Polyglot only uses locale for pluralization.\n\n\nPolyglot.prototype.locale = function (newLocale) {\n  if (newLocale) this.currentLocale = newLocale;\n  return this.currentLocale;\n}; // ### polyglot.extend(phrases)\n//\n// Use `extend` to tell Polyglot how to translate a given key.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The key can be any string.  Feel free to call `extend` multiple times;\n// it will override any phrases with the same key, but leave existing phrases\n// untouched.\n//\n// It is also possible to pass nested phrase objects, which get flattened\n// into an object with the nested keys concatenated using dot notation.\n//\n//     polyglot.extend({\n//       \"nav\": {\n//         \"hello\": \"Hello\",\n//         \"hello_name\": \"Hello, %{name}\",\n//         \"sidebar\": {\n//           \"welcome\": \"Welcome\"\n//         }\n//       }\n//     });\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}',\n//     //   'nav.sidebar.welcome': 'Welcome'\n//     // }\n//\n// `extend` accepts an optional second argument, `prefix`, which can be used\n// to prefix every key in the phrases object with some string, using dot\n// notation.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     }, \"nav\");\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}'\n//     // }\n//\n// This feature is used internally to support nested phrase objects.\n\n\nPolyglot.prototype.extend = function (morePhrases, prefix) {\n  forEach(morePhrases, function (phrase, key) {\n    var prefixedKey = prefix ? prefix + '.' + key : key;\n\n    if (typeof phrase === 'object') {\n      this.extend(phrase, prefixedKey);\n    } else {\n      this.phrases[prefixedKey] = phrase;\n    }\n  }, this);\n}; // ### polyglot.unset(phrases)\n// Use `unset` to selectively remove keys from a polyglot instance.\n//\n//     polyglot.unset(\"some_key\");\n//     polyglot.unset({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The unset method can take either a string (for the key), or an object hash with\n// the keys that you would like to unset.\n\n\nPolyglot.prototype.unset = function (morePhrases, prefix) {\n  if (typeof morePhrases === 'string') {\n    delete this.phrases[morePhrases];\n  } else {\n    forEach(morePhrases, function (phrase, key) {\n      var prefixedKey = prefix ? prefix + '.' + key : key;\n\n      if (typeof phrase === 'object') {\n        this.unset(phrase, prefixedKey);\n      } else {\n        delete this.phrases[prefixedKey];\n      }\n    }, this);\n  }\n}; // ### polyglot.clear()\n//\n// Clears all phrases. Useful for special cases, such as freeing\n// up memory if you have lots of phrases but no longer need to\n// perform any translation. Also used internally by `replace`.\n\n\nPolyglot.prototype.clear = function () {\n  this.phrases = {};\n}; // ### polyglot.replace(phrases)\n//\n// Completely replace the existing phrases with a new set of phrases.\n// Normally, just use `extend` to add more phrases, but under certain\n// circumstances, you may want to make sure no old phrases are lying around.\n\n\nPolyglot.prototype.replace = function (newPhrases) {\n  this.clear();\n  this.extend(newPhrases);\n}; // ### polyglot.t(key, options)\n//\n// The most-used method. Provide a key, and `t` will return the\n// phrase.\n//\n//     polyglot.t(\"hello\");\n//     => \"Hello\"\n//\n// The phrase value is provided first by a call to `polyglot.extend()` or\n// `polyglot.replace()`.\n//\n// Pass in an object as the second argument to perform interpolation.\n//\n//     polyglot.t(\"hello_name\", {name: \"Spike\"});\n//     => \"Hello, Spike\"\n//\n// If you like, you can provide a default value in case the phrase is missing.\n// Use the special option key \"_\" to specify a default.\n//\n//     polyglot.t(\"i_like_to_write_in_language\", {\n//       _: \"I like to write in %{language}.\",\n//       language: \"JavaScript\"\n//     });\n//     => \"I like to write in JavaScript.\"\n//\n\n\nPolyglot.prototype.t = function (key, options) {\n  var phrase, result;\n  var opts = options == null ? {} : options;\n\n  if (typeof this.phrases[key] === 'string') {\n    phrase = this.phrases[key];\n  } else if (typeof opts._ === 'string') {\n    phrase = opts._;\n  } else if (this.onMissingKey) {\n    var onMissingKey = this.onMissingKey;\n    result = onMissingKey(key, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  } else {\n    this.warn('Missing translation for key: \"' + key + '\"');\n    result = key;\n  }\n\n  if (typeof phrase === 'string') {\n    result = transformPhrase(phrase, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  }\n\n  return result;\n}; // ### polyglot.has(key)\n//\n// Check if polyglot has a translation for given key\n\n\nPolyglot.prototype.has = function (key) {\n  return has(this.phrases, key);\n}; // export transformPhrase\n\n\nPolyglot.transformPhrase = function transform(phrase, substitutions, locale) {\n  return transformPhrase(phrase, substitutions, locale);\n};\n\nmodule.exports = Polyglot;","map":{"version":3,"sources":["/node_modules/node-polyglot/index.js"],"names":["forEach","require","warning","has","trim","warn","message","replace","String","prototype","split","delimiter","russianPluralGroups","n","lastTwo","end","defaultPluralRules","pluralTypes","arabic","bosnian_serbian","chinese","croatian","french","german","russian","lithuanian","czech","polish","icelandic","slovenian","pluralTypeToLanguages","langToTypeMap","mapping","ret","langs","type","lang","pluralTypeName","pluralRules","locale","langToPluralType","call","en","pluralTypeIndex","count","escape","token","constructTokenRegex","opts","prefix","suffix","RangeError","RegExp","defaultTokenRegex","transformPhrase","phrase","substitutions","tokenRegex","TypeError","result","interpolationRegex","pluralRulesOrDefault","options","smart_count","texts","expression","argument","Polyglot","phrases","extend","currentLocale","allowMissing","onMissingKey","interpolation","newLocale","morePhrases","key","prefixedKey","unset","clear","newPhrases","t","_","transform","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAArB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,SAAD,CAArB;;AACA,IAAIE,GAAG,GAAGF,OAAO,CAAC,KAAD,CAAjB;;AACA,IAAIG,IAAI,GAAGH,OAAO,CAAC,uBAAD,CAAlB;;AAEA,IAAII,IAAI,GAAG,SAASA,IAAT,CAAcC,OAAd,EAAuB;AAChCJ,EAAAA,OAAO,CAAC,KAAD,EAAQI,OAAR,CAAP;AACD,CAFD;;AAIA,IAAIC,OAAO,GAAGC,MAAM,CAACC,SAAP,CAAiBF,OAA/B;AACA,IAAIG,KAAK,GAAGF,MAAM,CAACC,SAAP,CAAiBC,KAA7B,C,CAEA;AACA;;AACA,IAAIC,SAAS,GAAG,MAAhB;;AAEA,IAAIC,mBAAmB,GAAG,UAAUC,CAAV,EAAa;AACrC,MAAIC,OAAO,GAAGD,CAAC,GAAG,GAAlB;AACA,MAAIE,GAAG,GAAGD,OAAO,GAAG,EAApB;;AACA,MAAIA,OAAO,KAAK,EAAZ,IAAkBC,GAAG,KAAK,CAA9B,EAAiC;AAC/B,WAAO,CAAP;AACD;;AACD,MAAI,KAAKA,GAAL,IAAYA,GAAG,IAAI,CAAnB,IAAwB,EAAED,OAAO,IAAI,EAAX,IAAiBA,OAAO,IAAI,EAA9B,CAA5B,EAA+D;AAC7D,WAAO,CAAP;AACD;;AACD,SAAO,CAAP;AACD,CAVD;;AAYA,IAAIE,kBAAkB,GAAG;AACvB;AACAC,EAAAA,WAAW,EAAE;AACXC,IAAAA,MAAM,EAAE,UAAUL,CAAV,EAAa;AACnB;AACA,UAAIA,CAAC,GAAG,CAAR,EAAW;AAAE,eAAOA,CAAP;AAAW;;AACxB,UAAIC,OAAO,GAAGD,CAAC,GAAG,GAAlB;AACA,UAAIC,OAAO,IAAI,CAAX,IAAgBA,OAAO,IAAI,EAA/B,EAAmC,OAAO,CAAP;AACnC,aAAOA,OAAO,IAAI,EAAX,GAAgB,CAAhB,GAAoB,CAA3B;AACD,KAPU;AAQXK,IAAAA,eAAe,EAAEP,mBARN;AASXQ,IAAAA,OAAO,EAAE,YAAY;AAAE,aAAO,CAAP;AAAW,KATvB;AAUXC,IAAAA,QAAQ,EAAET,mBAVC;AAWXU,IAAAA,MAAM,EAAE,UAAUT,CAAV,EAAa;AAAE,aAAOA,CAAC,GAAG,CAAJ,GAAQ,CAAR,GAAY,CAAnB;AAAuB,KAXnC;AAYXU,IAAAA,MAAM,EAAE,UAAUV,CAAV,EAAa;AAAE,aAAOA,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,CAArB;AAAyB,KAZrC;AAaXW,IAAAA,OAAO,EAAEZ,mBAbE;AAcXa,IAAAA,UAAU,EAAE,UAAUZ,CAAV,EAAa;AACvB,UAAIA,CAAC,GAAG,EAAJ,KAAW,CAAX,IAAgBA,CAAC,GAAG,GAAJ,KAAY,EAAhC,EAAoC;AAAE,eAAO,CAAP;AAAW;;AACjD,aAAOA,CAAC,GAAG,EAAJ,IAAU,CAAV,IAAeA,CAAC,GAAG,EAAJ,IAAU,CAAzB,KAA+BA,CAAC,GAAG,GAAJ,GAAU,EAAV,IAAgBA,CAAC,GAAG,GAAJ,GAAU,EAAzD,IAA+D,CAA/D,GAAmE,CAA1E;AACD,KAjBU;AAkBXa,IAAAA,KAAK,EAAE,UAAUb,CAAV,EAAa;AAClB,UAAIA,CAAC,KAAK,CAAV,EAAa;AAAE,eAAO,CAAP;AAAW;;AAC1B,aAAQA,CAAC,IAAI,CAAL,IAAUA,CAAC,IAAI,CAAhB,GAAqB,CAArB,GAAyB,CAAhC;AACD,KArBU;AAsBXc,IAAAA,MAAM,EAAE,UAAUd,CAAV,EAAa;AACnB,UAAIA,CAAC,KAAK,CAAV,EAAa;AAAE,eAAO,CAAP;AAAW;;AAC1B,UAAIE,GAAG,GAAGF,CAAC,GAAG,EAAd;AACA,aAAO,KAAKE,GAAL,IAAYA,GAAG,IAAI,CAAnB,KAAyBF,CAAC,GAAG,GAAJ,GAAU,EAAV,IAAgBA,CAAC,GAAG,GAAJ,IAAW,EAApD,IAA0D,CAA1D,GAA8D,CAArE;AACD,KA1BU;AA2BXe,IAAAA,SAAS,EAAE,UAAUf,CAAV,EAAa;AAAE,aAAQA,CAAC,GAAG,EAAJ,KAAW,CAAX,IAAgBA,CAAC,GAAG,GAAJ,KAAY,EAA7B,GAAmC,CAAnC,GAAuC,CAA9C;AAAkD,KA3BjE;AA4BXgB,IAAAA,SAAS,EAAE,UAAUhB,CAAV,EAAa;AACtB,UAAIC,OAAO,GAAGD,CAAC,GAAG,GAAlB;;AACA,UAAIC,OAAO,KAAK,CAAhB,EAAmB;AACjB,eAAO,CAAP;AACD;;AACD,UAAIA,OAAO,KAAK,CAAhB,EAAmB;AACjB,eAAO,CAAP;AACD;;AACD,UAAIA,OAAO,KAAK,CAAZ,IAAiBA,OAAO,KAAK,CAAjC,EAAoC;AAClC,eAAO,CAAP;AACD;;AACD,aAAO,CAAP;AACD;AAxCU,GAFU;AA6CvB;AACA;AACA;AACAgB,EAAAA,qBAAqB,EAAE;AACrBZ,IAAAA,MAAM,EAAE,CAAC,IAAD,CADa;AAErBC,IAAAA,eAAe,EAAE,CAAC,YAAD,EAAe,YAAf,EAA6B,QAA7B,EAAuC,OAAvC,CAFI;AAGrBC,IAAAA,OAAO,EAAE,CAAC,IAAD,EAAO,OAAP,EAAgB,IAAhB,EAAsB,IAAtB,EAA4B,OAA5B,EAAqC,IAArC,EAA2C,IAA3C,EAAiD,IAAjD,EAAuD,OAAvD,EAAgE,IAAhE,CAHY;AAIrBC,IAAAA,QAAQ,EAAE,CAAC,IAAD,EAAO,OAAP,CAJW;AAKrBE,IAAAA,MAAM,EAAE,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,EAAiD,OAAjD,EAA0D,IAA1D,EAAgE,OAAhE,EAAyE,IAAzE,EAA+E,IAA/E,EAAqF,IAArF,EAA2F,IAA3F,EAAiG,IAAjG,EAAuG,IAAvG,CALa;AAMrBD,IAAAA,MAAM,EAAE,CAAC,IAAD,EAAO,IAAP,EAAa,OAAb,CANa;AAOrBE,IAAAA,OAAO,EAAE,CAAC,IAAD,EAAO,OAAP,CAPY;AAQrBC,IAAAA,UAAU,EAAE,CAAC,IAAD,CARS;AASrBC,IAAAA,KAAK,EAAE,CAAC,IAAD,EAAO,OAAP,EAAgB,IAAhB,CATc;AAUrBC,IAAAA,MAAM,EAAE,CAAC,IAAD,CAVa;AAWrBC,IAAAA,SAAS,EAAE,CAAC,IAAD,CAXU;AAYrBC,IAAAA,SAAS,EAAE,CAAC,OAAD;AAZU;AAhDA,CAAzB;;AAgEA,SAASE,aAAT,CAAuBC,OAAvB,EAAgC;AAC9B,MAAIC,GAAG,GAAG,EAAV;AACAjC,EAAAA,OAAO,CAACgC,OAAD,EAAU,UAAUE,KAAV,EAAiBC,IAAjB,EAAuB;AACtCnC,IAAAA,OAAO,CAACkC,KAAD,EAAQ,UAAUE,IAAV,EAAgB;AAC7BH,MAAAA,GAAG,CAACG,IAAD,CAAH,GAAYD,IAAZ;AACD,KAFM,CAAP;AAGD,GAJM,CAAP;AAKA,SAAOF,GAAP;AACD;;AAED,SAASI,cAAT,CAAwBC,WAAxB,EAAqCC,MAArC,EAA6C;AAC3C,MAAIC,gBAAgB,GAAGT,aAAa,CAACO,WAAW,CAACR,qBAAb,CAApC;AACA,SAAOU,gBAAgB,CAACD,MAAD,CAAhB,IACFC,gBAAgB,CAAC9B,KAAK,CAAC+B,IAAN,CAAWF,MAAX,EAAmB,GAAnB,EAAwB,CAAxB,EAA2B,CAA3B,CAAD,CADd,IAEFC,gBAAgB,CAACE,EAFtB;AAGD;;AAED,SAASC,eAAT,CAAyBL,WAAzB,EAAsCC,MAAtC,EAA8CK,KAA9C,EAAqD;AACnD,SAAON,WAAW,CAACrB,WAAZ,CAAwBoB,cAAc,CAACC,WAAD,EAAcC,MAAd,CAAtC,EAA6DK,KAA7D,CAAP;AACD;;AAED,SAASC,MAAT,CAAgBC,KAAhB,EAAuB;AACrB,SAAOA,KAAK,CAACvC,OAAN,CAAc,qBAAd,EAAqC,MAArC,CAAP;AACD;;AAED,SAASwC,mBAAT,CAA6BC,IAA7B,EAAmC;AACjC,MAAIC,MAAM,GAAID,IAAI,IAAIA,IAAI,CAACC,MAAd,IAAyB,IAAtC;AACA,MAAIC,MAAM,GAAIF,IAAI,IAAIA,IAAI,CAACE,MAAd,IAAyB,GAAtC;;AAEA,MAAID,MAAM,KAAKtC,SAAX,IAAwBuC,MAAM,KAAKvC,SAAvC,EAAkD;AAChD,UAAM,IAAIwC,UAAJ,CAAe,MAAMxC,SAAN,GAAkB,uCAAjC,CAAN;AACD;;AAED,SAAO,IAAIyC,MAAJ,CAAWP,MAAM,CAACI,MAAD,CAAN,GAAiB,OAAjB,GAA2BJ,MAAM,CAACK,MAAD,CAA5C,EAAsD,GAAtD,CAAP;AACD;;AAED,IAAIG,iBAAiB,GAAG,aAAxB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,eAAT,CAAyBC,MAAzB,EAAiCC,aAAjC,EAAgDjB,MAAhD,EAAwDkB,UAAxD,EAAoEnB,WAApE,EAAiF;AAC/E,MAAI,OAAOiB,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,UAAM,IAAIG,SAAJ,CAAc,2DAAd,CAAN;AACD;;AAED,MAAIF,aAAa,IAAI,IAArB,EAA2B;AACzB,WAAOD,MAAP;AACD;;AAED,MAAII,MAAM,GAAGJ,MAAb;AACA,MAAIK,kBAAkB,GAAGH,UAAU,IAAIJ,iBAAvC;AACA,MAAIQ,oBAAoB,GAAGvB,WAAW,IAAItB,kBAA1C,CAX+E,CAa/E;;AACA,MAAI8C,OAAO,GAAG,OAAON,aAAP,KAAyB,QAAzB,GAAoC;AAAEO,IAAAA,WAAW,EAAEP;AAAf,GAApC,GAAqEA,aAAnF,CAd+E,CAgB/E;AACA;AACA;;AACA,MAAIM,OAAO,CAACC,WAAR,IAAuB,IAAvB,IAA+BJ,MAAnC,EAA2C;AACzC,QAAIK,KAAK,GAAGtD,KAAK,CAAC+B,IAAN,CAAWkB,MAAX,EAAmBhD,SAAnB,CAAZ;AACAgD,IAAAA,MAAM,GAAGvD,IAAI,CAAC4D,KAAK,CAACrB,eAAe,CAACkB,oBAAD,EAAuBtB,MAAM,IAAI,IAAjC,EAAuCuB,OAAO,CAACC,WAA/C,CAAhB,CAAL,IAAqFC,KAAK,CAAC,CAAD,CAA3F,CAAb;AACD,GAtB8E,CAwB/E;;;AACAL,EAAAA,MAAM,GAAGpD,OAAO,CAACkC,IAAR,CAAakB,MAAb,EAAqBC,kBAArB,EAAyC,UAAUK,UAAV,EAAsBC,QAAtB,EAAgC;AAChF,QAAI,CAAC/D,GAAG,CAAC2D,OAAD,EAAUI,QAAV,CAAJ,IAA2BJ,OAAO,CAACI,QAAD,CAAP,IAAqB,IAApD,EAA0D;AAAE,aAAOD,UAAP;AAAoB;;AAChF,WAAOH,OAAO,CAACI,QAAD,CAAd;AACD,GAHQ,CAAT;AAKA,SAAOP,MAAP;AACD,C,CAED;;;AACA,SAASQ,QAAT,CAAkBL,OAAlB,EAA2B;AACzB,MAAId,IAAI,GAAGc,OAAO,IAAI,EAAtB;AACA,OAAKM,OAAL,GAAe,EAAf;AACA,OAAKC,MAAL,CAAYrB,IAAI,CAACoB,OAAL,IAAgB,EAA5B;AACA,OAAKE,aAAL,GAAqBtB,IAAI,CAACT,MAAL,IAAe,IAApC;AACA,MAAIgC,YAAY,GAAGvB,IAAI,CAACuB,YAAL,GAAoBjB,eAApB,GAAsC,IAAzD;AACA,OAAKkB,YAAL,GAAoB,OAAOxB,IAAI,CAACwB,YAAZ,KAA6B,UAA7B,GAA0CxB,IAAI,CAACwB,YAA/C,GAA8DD,YAAlF;AACA,OAAKlE,IAAL,GAAY2C,IAAI,CAAC3C,IAAL,IAAaA,IAAzB;AACA,OAAKoD,UAAL,GAAkBV,mBAAmB,CAACC,IAAI,CAACyB,aAAN,CAArC;AACA,OAAKnC,WAAL,GAAmBU,IAAI,CAACV,WAAL,IAAoBtB,kBAAvC;AACD,C,CAED;AACA;AACA;;;AACAmD,QAAQ,CAAC1D,SAAT,CAAmB8B,MAAnB,GAA4B,UAAUmC,SAAV,EAAqB;AAC/C,MAAIA,SAAJ,EAAe,KAAKJ,aAAL,GAAqBI,SAArB;AACf,SAAO,KAAKJ,aAAZ;AACD,CAHD,C,CAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAH,QAAQ,CAAC1D,SAAT,CAAmB4D,MAAnB,GAA4B,UAAUM,WAAV,EAAuB1B,MAAvB,EAA+B;AACzDjD,EAAAA,OAAO,CAAC2E,WAAD,EAAc,UAAUpB,MAAV,EAAkBqB,GAAlB,EAAuB;AAC1C,QAAIC,WAAW,GAAG5B,MAAM,GAAGA,MAAM,GAAG,GAAT,GAAe2B,GAAlB,GAAwBA,GAAhD;;AACA,QAAI,OAAOrB,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,WAAKc,MAAL,CAAYd,MAAZ,EAAoBsB,WAApB;AACD,KAFD,MAEO;AACL,WAAKT,OAAL,CAAaS,WAAb,IAA4BtB,MAA5B;AACD;AACF,GAPM,EAOJ,IAPI,CAAP;AAQD,CATD,C,CAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAY,QAAQ,CAAC1D,SAAT,CAAmBqE,KAAnB,GAA2B,UAAUH,WAAV,EAAuB1B,MAAvB,EAA+B;AACxD,MAAI,OAAO0B,WAAP,KAAuB,QAA3B,EAAqC;AACnC,WAAO,KAAKP,OAAL,CAAaO,WAAb,CAAP;AACD,GAFD,MAEO;AACL3E,IAAAA,OAAO,CAAC2E,WAAD,EAAc,UAAUpB,MAAV,EAAkBqB,GAAlB,EAAuB;AAC1C,UAAIC,WAAW,GAAG5B,MAAM,GAAGA,MAAM,GAAG,GAAT,GAAe2B,GAAlB,GAAwBA,GAAhD;;AACA,UAAI,OAAOrB,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,aAAKuB,KAAL,CAAWvB,MAAX,EAAmBsB,WAAnB;AACD,OAFD,MAEO;AACL,eAAO,KAAKT,OAAL,CAAaS,WAAb,CAAP;AACD;AACF,KAPM,EAOJ,IAPI,CAAP;AAQD;AACF,CAbD,C,CAeA;AACA;AACA;AACA;AACA;;;AACAV,QAAQ,CAAC1D,SAAT,CAAmBsE,KAAnB,GAA2B,YAAY;AACrC,OAAKX,OAAL,GAAe,EAAf;AACD,CAFD,C,CAIA;AACA;AACA;AACA;AACA;;;AACAD,QAAQ,CAAC1D,SAAT,CAAmBF,OAAnB,GAA6B,UAAUyE,UAAV,EAAsB;AACjD,OAAKD,KAAL;AACA,OAAKV,MAAL,CAAYW,UAAZ;AACD,CAHD,C,CAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAb,QAAQ,CAAC1D,SAAT,CAAmBwE,CAAnB,GAAuB,UAAUL,GAAV,EAAed,OAAf,EAAwB;AAC7C,MAAIP,MAAJ,EAAYI,MAAZ;AACA,MAAIX,IAAI,GAAGc,OAAO,IAAI,IAAX,GAAkB,EAAlB,GAAuBA,OAAlC;;AACA,MAAI,OAAO,KAAKM,OAAL,CAAaQ,GAAb,CAAP,KAA6B,QAAjC,EAA2C;AACzCrB,IAAAA,MAAM,GAAG,KAAKa,OAAL,CAAaQ,GAAb,CAAT;AACD,GAFD,MAEO,IAAI,OAAO5B,IAAI,CAACkC,CAAZ,KAAkB,QAAtB,EAAgC;AACrC3B,IAAAA,MAAM,GAAGP,IAAI,CAACkC,CAAd;AACD,GAFM,MAEA,IAAI,KAAKV,YAAT,EAAuB;AAC5B,QAAIA,YAAY,GAAG,KAAKA,YAAxB;AACAb,IAAAA,MAAM,GAAGa,YAAY,CAACI,GAAD,EAAM5B,IAAN,EAAY,KAAKsB,aAAjB,EAAgC,KAAKb,UAArC,EAAiD,KAAKnB,WAAtD,CAArB;AACD,GAHM,MAGA;AACL,SAAKjC,IAAL,CAAU,mCAAmCuE,GAAnC,GAAyC,GAAnD;AACAjB,IAAAA,MAAM,GAAGiB,GAAT;AACD;;AACD,MAAI,OAAOrB,MAAP,KAAkB,QAAtB,EAAgC;AAC9BI,IAAAA,MAAM,GAAGL,eAAe,CAACC,MAAD,EAASP,IAAT,EAAe,KAAKsB,aAApB,EAAmC,KAAKb,UAAxC,EAAoD,KAAKnB,WAAzD,CAAxB;AACD;;AACD,SAAOqB,MAAP;AACD,CAlBD,C,CAqBA;AACA;AACA;;;AACAQ,QAAQ,CAAC1D,SAAT,CAAmBN,GAAnB,GAAyB,UAAUyE,GAAV,EAAe;AACtC,SAAOzE,GAAG,CAAC,KAAKiE,OAAN,EAAeQ,GAAf,CAAV;AACD,CAFD,C,CAIA;;;AACAT,QAAQ,CAACb,eAAT,GAA2B,SAAS6B,SAAT,CAAmB5B,MAAnB,EAA2BC,aAA3B,EAA0CjB,MAA1C,EAAkD;AAC3E,SAAOe,eAAe,CAACC,MAAD,EAASC,aAAT,EAAwBjB,MAAxB,CAAtB;AACD,CAFD;;AAIA6C,MAAM,CAACC,OAAP,GAAiBlB,QAAjB","sourcesContent":["//     (c) 2012-2018 Airbnb, Inc.\n//\n//     polyglot.js may be freely distributed under the terms of the BSD\n//     license. For all licensing information, details, and documention:\n//     http://airbnb.github.com/polyglot.js\n//\n//\n// Polyglot.js is an I18n helper library written in JavaScript, made to\n// work both in the browser and in Node. It provides a simple solution for\n// interpolation and pluralization, based off of Airbnb's\n// experience adding I18n functionality to its Backbone.js and Node apps.\n//\n// Polylglot is agnostic to your translation backend. It doesn't perform any\n// translation; it simply gives you a way to manage translated phrases from\n// your client- or server-side JavaScript application.\n//\n\n'use strict';\n\nvar forEach = require('for-each');\nvar warning = require('warning');\nvar has = require('has');\nvar trim = require('string.prototype.trim');\n\nvar warn = function warn(message) {\n  warning(false, message);\n};\n\nvar replace = String.prototype.replace;\nvar split = String.prototype.split;\n\n// #### Pluralization methods\n// The string that separates the different phrase possibilities.\nvar delimiter = '||||';\n\nvar russianPluralGroups = function (n) {\n  var lastTwo = n % 100;\n  var end = lastTwo % 10;\n  if (lastTwo !== 11 && end === 1) {\n    return 0;\n  }\n  if (2 <= end && end <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {\n    return 1;\n  }\n  return 2;\n};\n\nvar defaultPluralRules = {\n  // Mapping from pluralization group plural logic.\n  pluralTypes: {\n    arabic: function (n) {\n      // http://www.arabeyes.org/Plural_Forms\n      if (n < 3) { return n; }\n      var lastTwo = n % 100;\n      if (lastTwo >= 3 && lastTwo <= 10) return 3;\n      return lastTwo >= 11 ? 4 : 5;\n    },\n    bosnian_serbian: russianPluralGroups,\n    chinese: function () { return 0; },\n    croatian: russianPluralGroups,\n    french: function (n) { return n > 1 ? 1 : 0; },\n    german: function (n) { return n !== 1 ? 1 : 0; },\n    russian: russianPluralGroups,\n    lithuanian: function (n) {\n      if (n % 10 === 1 && n % 100 !== 11) { return 0; }\n      return n % 10 >= 2 && n % 10 <= 9 && (n % 100 < 11 || n % 100 > 19) ? 1 : 2;\n    },\n    czech: function (n) {\n      if (n === 1) { return 0; }\n      return (n >= 2 && n <= 4) ? 1 : 2;\n    },\n    polish: function (n) {\n      if (n === 1) { return 0; }\n      var end = n % 10;\n      return 2 <= end && end <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    icelandic: function (n) { return (n % 10 !== 1 || n % 100 === 11) ? 1 : 0; },\n    slovenian: function (n) {\n      var lastTwo = n % 100;\n      if (lastTwo === 1) {\n        return 0;\n      }\n      if (lastTwo === 2) {\n        return 1;\n      }\n      if (lastTwo === 3 || lastTwo === 4) {\n        return 2;\n      }\n      return 3;\n    }\n  },\n\n  // Mapping from pluralization group to individual language codes/locales.\n  // Will look up based on exact match, if not found and it's a locale will parse the locale\n  // for language code, and if that does not exist will default to 'en'\n  pluralTypeToLanguages: {\n    arabic: ['ar'],\n    bosnian_serbian: ['bs-Latn-BA', 'bs-Cyrl-BA', 'srl-RS', 'sr-RS'],\n    chinese: ['id', 'id-ID', 'ja', 'ko', 'ko-KR', 'lo', 'ms', 'th', 'th-TH', 'zh'],\n    croatian: ['hr', 'hr-HR'],\n    german: ['fa', 'da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hi-IN', 'hu', 'hu-HU', 'it', 'nl', 'no', 'pt', 'sv', 'tr'],\n    french: ['fr', 'tl', 'pt-br'],\n    russian: ['ru', 'ru-RU'],\n    lithuanian: ['lt'],\n    czech: ['cs', 'cs-CZ', 'sk'],\n    polish: ['pl'],\n    icelandic: ['is'],\n    slovenian: ['sl-SL']\n  }\n};\n\nfunction langToTypeMap(mapping) {\n  var ret = {};\n  forEach(mapping, function (langs, type) {\n    forEach(langs, function (lang) {\n      ret[lang] = type;\n    });\n  });\n  return ret;\n}\n\nfunction pluralTypeName(pluralRules, locale) {\n  var langToPluralType = langToTypeMap(pluralRules.pluralTypeToLanguages);\n  return langToPluralType[locale]\n    || langToPluralType[split.call(locale, /-/, 1)[0]]\n    || langToPluralType.en;\n}\n\nfunction pluralTypeIndex(pluralRules, locale, count) {\n  return pluralRules.pluralTypes[pluralTypeName(pluralRules, locale)](count);\n}\n\nfunction escape(token) {\n  return token.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction constructTokenRegex(opts) {\n  var prefix = (opts && opts.prefix) || '%{';\n  var suffix = (opts && opts.suffix) || '}';\n\n  if (prefix === delimiter || suffix === delimiter) {\n    throw new RangeError('\"' + delimiter + '\" token is reserved for pluralization');\n  }\n\n  return new RegExp(escape(prefix) + '(.*?)' + escape(suffix), 'g');\n}\n\nvar defaultTokenRegex = /%\\{(.*?)\\}/g;\n\n// ### transformPhrase(phrase, substitutions, locale)\n//\n// Takes a phrase string and transforms it by choosing the correct\n// plural form and interpolating it.\n//\n//     transformPhrase('Hello, %{name}!', {name: 'Spike'});\n//     // \"Hello, Spike!\"\n//\n// The correct plural form is selected if substitutions.smart_count\n// is set. You can pass in a number instead of an Object as `substitutions`\n// as a shortcut for `smart_count`.\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 1}, 'en');\n//     // \"1 new message\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 2}, 'en');\n//     // \"2 new messages\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', 5, 'en');\n//     // \"5 new messages\"\n//\n// You should pass in a third argument, the locale, to specify the correct plural type.\n// It defaults to `'en'` with 2 plural forms.\nfunction transformPhrase(phrase, substitutions, locale, tokenRegex, pluralRules) {\n  if (typeof phrase !== 'string') {\n    throw new TypeError('Polyglot.transformPhrase expects argument #1 to be string');\n  }\n\n  if (substitutions == null) {\n    return phrase;\n  }\n\n  var result = phrase;\n  var interpolationRegex = tokenRegex || defaultTokenRegex;\n  var pluralRulesOrDefault = pluralRules || defaultPluralRules;\n\n  // allow number as a pluralization shortcut\n  var options = typeof substitutions === 'number' ? { smart_count: substitutions } : substitutions;\n\n  // Select plural form: based on a phrase text that contains `n`\n  // plural forms separated by `delimiter`, a `locale`, and a `substitutions.smart_count`,\n  // choose the correct plural form. This is only done if `count` is set.\n  if (options.smart_count != null && result) {\n    var texts = split.call(result, delimiter);\n    result = trim(texts[pluralTypeIndex(pluralRulesOrDefault, locale || 'en', options.smart_count)] || texts[0]);\n  }\n\n  // Interpolate: Creates a `RegExp` object for each interpolation placeholder.\n  result = replace.call(result, interpolationRegex, function (expression, argument) {\n    if (!has(options, argument) || options[argument] == null) { return expression; }\n    return options[argument];\n  });\n\n  return result;\n}\n\n// ### Polyglot class constructor\nfunction Polyglot(options) {\n  var opts = options || {};\n  this.phrases = {};\n  this.extend(opts.phrases || {});\n  this.currentLocale = opts.locale || 'en';\n  var allowMissing = opts.allowMissing ? transformPhrase : null;\n  this.onMissingKey = typeof opts.onMissingKey === 'function' ? opts.onMissingKey : allowMissing;\n  this.warn = opts.warn || warn;\n  this.tokenRegex = constructTokenRegex(opts.interpolation);\n  this.pluralRules = opts.pluralRules || defaultPluralRules;\n}\n\n// ### polyglot.locale([locale])\n//\n// Get or set locale. Internally, Polyglot only uses locale for pluralization.\nPolyglot.prototype.locale = function (newLocale) {\n  if (newLocale) this.currentLocale = newLocale;\n  return this.currentLocale;\n};\n\n// ### polyglot.extend(phrases)\n//\n// Use `extend` to tell Polyglot how to translate a given key.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The key can be any string.  Feel free to call `extend` multiple times;\n// it will override any phrases with the same key, but leave existing phrases\n// untouched.\n//\n// It is also possible to pass nested phrase objects, which get flattened\n// into an object with the nested keys concatenated using dot notation.\n//\n//     polyglot.extend({\n//       \"nav\": {\n//         \"hello\": \"Hello\",\n//         \"hello_name\": \"Hello, %{name}\",\n//         \"sidebar\": {\n//           \"welcome\": \"Welcome\"\n//         }\n//       }\n//     });\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}',\n//     //   'nav.sidebar.welcome': 'Welcome'\n//     // }\n//\n// `extend` accepts an optional second argument, `prefix`, which can be used\n// to prefix every key in the phrases object with some string, using dot\n// notation.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     }, \"nav\");\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}'\n//     // }\n//\n// This feature is used internally to support nested phrase objects.\nPolyglot.prototype.extend = function (morePhrases, prefix) {\n  forEach(morePhrases, function (phrase, key) {\n    var prefixedKey = prefix ? prefix + '.' + key : key;\n    if (typeof phrase === 'object') {\n      this.extend(phrase, prefixedKey);\n    } else {\n      this.phrases[prefixedKey] = phrase;\n    }\n  }, this);\n};\n\n// ### polyglot.unset(phrases)\n// Use `unset` to selectively remove keys from a polyglot instance.\n//\n//     polyglot.unset(\"some_key\");\n//     polyglot.unset({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The unset method can take either a string (for the key), or an object hash with\n// the keys that you would like to unset.\nPolyglot.prototype.unset = function (morePhrases, prefix) {\n  if (typeof morePhrases === 'string') {\n    delete this.phrases[morePhrases];\n  } else {\n    forEach(morePhrases, function (phrase, key) {\n      var prefixedKey = prefix ? prefix + '.' + key : key;\n      if (typeof phrase === 'object') {\n        this.unset(phrase, prefixedKey);\n      } else {\n        delete this.phrases[prefixedKey];\n      }\n    }, this);\n  }\n};\n\n// ### polyglot.clear()\n//\n// Clears all phrases. Useful for special cases, such as freeing\n// up memory if you have lots of phrases but no longer need to\n// perform any translation. Also used internally by `replace`.\nPolyglot.prototype.clear = function () {\n  this.phrases = {};\n};\n\n// ### polyglot.replace(phrases)\n//\n// Completely replace the existing phrases with a new set of phrases.\n// Normally, just use `extend` to add more phrases, but under certain\n// circumstances, you may want to make sure no old phrases are lying around.\nPolyglot.prototype.replace = function (newPhrases) {\n  this.clear();\n  this.extend(newPhrases);\n};\n\n\n// ### polyglot.t(key, options)\n//\n// The most-used method. Provide a key, and `t` will return the\n// phrase.\n//\n//     polyglot.t(\"hello\");\n//     => \"Hello\"\n//\n// The phrase value is provided first by a call to `polyglot.extend()` or\n// `polyglot.replace()`.\n//\n// Pass in an object as the second argument to perform interpolation.\n//\n//     polyglot.t(\"hello_name\", {name: \"Spike\"});\n//     => \"Hello, Spike\"\n//\n// If you like, you can provide a default value in case the phrase is missing.\n// Use the special option key \"_\" to specify a default.\n//\n//     polyglot.t(\"i_like_to_write_in_language\", {\n//       _: \"I like to write in %{language}.\",\n//       language: \"JavaScript\"\n//     });\n//     => \"I like to write in JavaScript.\"\n//\nPolyglot.prototype.t = function (key, options) {\n  var phrase, result;\n  var opts = options == null ? {} : options;\n  if (typeof this.phrases[key] === 'string') {\n    phrase = this.phrases[key];\n  } else if (typeof opts._ === 'string') {\n    phrase = opts._;\n  } else if (this.onMissingKey) {\n    var onMissingKey = this.onMissingKey;\n    result = onMissingKey(key, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  } else {\n    this.warn('Missing translation for key: \"' + key + '\"');\n    result = key;\n  }\n  if (typeof phrase === 'string') {\n    result = transformPhrase(phrase, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  }\n  return result;\n};\n\n\n// ### polyglot.has(key)\n//\n// Check if polyglot has a translation for given key\nPolyglot.prototype.has = function (key) {\n  return has(this.phrases, key);\n};\n\n// export transformPhrase\nPolyglot.transformPhrase = function transform(phrase, substitutions, locale) {\n  return transformPhrase(phrase, substitutions, locale);\n};\n\nmodule.exports = Polyglot;\n"]},"metadata":{},"sourceType":"script"}