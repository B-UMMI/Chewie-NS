{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nimport { useMemo } from 'react';\nimport ReactDOM from 'react-dom';\nimport { useSelector } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport debounce from 'lodash/debounce';\nimport union from 'lodash/union';\nimport isEqual from 'lodash/isEqual';\nimport { CRUD_GET_MANY } from '../actions/dataActions/crudGetMany';\nimport { useSafeSetState } from '../util/hooks';\nimport useDataProvider from './useDataProvider';\nimport { useEffect } from 'react';\nvar queriesToCall = {};\nvar dataProvider;\nvar DataProviderOptions = {\n  action: CRUD_GET_MANY\n};\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { loading: true, loaded: false }\n * - success: { data: [data from response], loading: false, loaded: true }\n * - error: { error: [error from response], loading: false, loaded: true }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetMany('tags', [1, 2, 3]);\n * useGetMany('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider(GET_MANY, 'tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param ids The resource identifiers, e.g. [123, 456, 789]\n * @param options Options object to pass to the dataProvider. May include side effects to be executed upon success or failure, e.g. { onSuccess: { refresh: true } }\n *\n * @returns The current request state. Destructure as { data, error, loading, loaded }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ record }) => {\n *     const { data, loading, error } = useGetMany('tags', record.tagIds);\n *     if (loading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\n\nvar useGetMany = function (resource, ids, options) {\n  if (options === void 0) {\n    options = {};\n  } // we can't use useQueryWithStore here because we're aggregating queries first\n  // therefore part of the useQueryWithStore logic will have to be repeated below\n\n\n  var selectMany = useMemo(makeGetManySelector, []);\n  var data = useSelector(function (state) {\n    return selectMany(state, resource, ids);\n  });\n\n  var _a = useSafeSetState({\n    data: data,\n    error: null,\n    loading: ids.length !== 0,\n    loaded: ids.length === 0 || data.length !== 0 && !data.includes(undefined)\n  }),\n      state = _a[0],\n      setState = _a[1];\n\n  if (!isEqual(state.data, data)) {\n    setState(__assign(__assign({}, state), {\n      data: data,\n      loaded: true\n    }));\n  }\n\n  dataProvider = useDataProvider(); // not the best way to pass the dataProvider to a function outside the hook, but I couldn't find a better one\n\n  useEffect(function () {\n    if (!queriesToCall[resource]) {\n      queriesToCall[resource] = [];\n    }\n    /**\n     * queriesToCall stores the queries to call under the following shape:\n     *\n     * {\n     *   'posts': [\n     *     { ids: [1, 2], setState }\n     *     { ids: [2, 3], setState, onSuccess }\n     *     { ids: [4, 5], setState }\n     *   ],\n     *   'comments': [\n     *     { ids: [345], setState, onFailure }\n     *   ]\n     * }\n     */\n\n\n    queriesToCall[resource] = queriesToCall[resource].concat({\n      ids: ids,\n      setState: setState,\n      onSuccess: options && options.onSuccess,\n      onFailure: options && options.onFailure\n    });\n    callQueries(); // debounced by lodash\n  }, [JSON.stringify({\n    resource: resource,\n    ids: ids,\n    options: options\n  }), dataProvider]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return state;\n};\n/**\n * Memoized selector for getting an array of resources based on an array of ids\n *\n * @see https://react-redux.js.org/next/api/hooks#using-memoizing-selectors\n */\n\n\nvar makeGetManySelector = function () {\n  return createSelector(function (state) {\n    return state.admin.resources;\n  }, function (_, resource) {\n    return resource;\n  }, function (_, __, ids) {\n    return ids;\n  }, function (resources, resource, ids) {\n    return resources[resource] ? ids.map(function (id) {\n      return resources[resource].data[id];\n    }) : ids.map(function (id) {\n      return undefined;\n    });\n  });\n};\n/**\n * Call the dataProvider once per resource\n */\n\n\nvar callQueries = debounce(function () {\n  var resources = Object.keys(queriesToCall);\n  resources.forEach(function (resource) {\n    var queries = __spreadArrays(queriesToCall[resource]); // cloning to avoid side effects\n\n    /**\n     * Extract ids from queries, aggregate and deduplicate them\n     *\n     * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n     */\n\n\n    var accumulatedIds = queries.reduce(function (acc, _a) {\n      var ids = _a.ids;\n      return union(acc, ids);\n    }, []) // concat + unique\n    .filter(function (v) {\n      return v != null && v !== '';\n    }); // remove null values\n\n    if (accumulatedIds.length === 0) {\n      // no need to call the data provider if all the ids are null\n      queries.forEach(function (_a) {\n        var ids = _a.ids,\n            setState = _a.setState,\n            onSuccess = _a.onSuccess;\n        setState({\n          data: emptyArray,\n          loading: false,\n          loaded: true\n        });\n\n        if (onSuccess) {\n          onSuccess({\n            data: emptyArray\n          });\n        }\n      });\n      return;\n    }\n\n    dataProvider.getMany(resource, {\n      ids: accumulatedIds\n    }, DataProviderOptions).then(function (response) {\n      // Forces batching, see https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var ids = _a.ids,\n              setState = _a.setState,\n              onSuccess = _a.onSuccess;\n          setState(function (prevState) {\n            return __assign(__assign({}, prevState), {\n              error: null,\n              loading: false,\n              loaded: true\n            });\n          });\n\n          if (onSuccess) {\n            var subData = ids.map(function (id) {\n              return response.data.find(function (datum) {\n                return datum.id == id;\n              });\n            } // eslint-disable-line eqeqeq\n            );\n            onSuccess({\n              data: subData\n            });\n          }\n        });\n      });\n    }).catch(function (error) {\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var setState = _a.setState,\n              onFailure = _a.onFailure;\n          setState({\n            error: error,\n            loading: false,\n            loaded: false\n          });\n          onFailure && onFailure(error);\n        });\n      });\n    });\n    delete queriesToCall[resource];\n  });\n});\nvar emptyArray = [];\nexport default useGetMany;","map":{"version":3,"sources":["/node_modules/ra-core/esm/dataProvider/useGetMany.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArrays","il","r","Array","k","a","j","jl","useMemo","ReactDOM","useSelector","createSelector","debounce","union","isEqual","CRUD_GET_MANY","useSafeSetState","useDataProvider","useEffect","queriesToCall","dataProvider","DataProviderOptions","action","useGetMany","resource","ids","options","selectMany","makeGetManySelector","data","state","_a","error","loading","loaded","includes","undefined","setState","concat","onSuccess","onFailure","callQueries","JSON","stringify","admin","resources","_","__","map","id","keys","forEach","queries","accumulatedIds","reduce","acc","filter","v","emptyArray","getMany","then","response","unstable_batchedUpdates","prevState","subData","find","datum","catch"],"mappings":"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","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport { useMemo } from 'react';\nimport ReactDOM from 'react-dom';\nimport { useSelector } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport debounce from 'lodash/debounce';\nimport union from 'lodash/union';\nimport isEqual from 'lodash/isEqual';\nimport { CRUD_GET_MANY } from '../actions/dataActions/crudGetMany';\nimport { useSafeSetState } from '../util/hooks';\nimport useDataProvider from './useDataProvider';\nimport { useEffect } from 'react';\nvar queriesToCall = {};\nvar dataProvider;\nvar DataProviderOptions = { action: CRUD_GET_MANY };\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { loading: true, loaded: false }\n * - success: { data: [data from response], loading: false, loaded: true }\n * - error: { error: [error from response], loading: false, loaded: true }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetMany('tags', [1, 2, 3]);\n * useGetMany('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider(GET_MANY, 'tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param ids The resource identifiers, e.g. [123, 456, 789]\n * @param options Options object to pass to the dataProvider. May include side effects to be executed upon success or failure, e.g. { onSuccess: { refresh: true } }\n *\n * @returns The current request state. Destructure as { data, error, loading, loaded }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ record }) => {\n *     const { data, loading, error } = useGetMany('tags', record.tagIds);\n *     if (loading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\nvar useGetMany = function (resource, ids, options) {\n    if (options === void 0) { options = {}; }\n    // we can't use useQueryWithStore here because we're aggregating queries first\n    // therefore part of the useQueryWithStore logic will have to be repeated below\n    var selectMany = useMemo(makeGetManySelector, []);\n    var data = useSelector(function (state) {\n        return selectMany(state, resource, ids);\n    });\n    var _a = useSafeSetState({\n        data: data,\n        error: null,\n        loading: ids.length !== 0,\n        loaded: ids.length === 0 ||\n            (data.length !== 0 && !data.includes(undefined)),\n    }), state = _a[0], setState = _a[1];\n    if (!isEqual(state.data, data)) {\n        setState(__assign(__assign({}, state), { data: data, loaded: true }));\n    }\n    dataProvider = useDataProvider(); // not the best way to pass the dataProvider to a function outside the hook, but I couldn't find a better one\n    useEffect(function () {\n        if (!queriesToCall[resource]) {\n            queriesToCall[resource] = [];\n        }\n        /**\n         * queriesToCall stores the queries to call under the following shape:\n         *\n         * {\n         *   'posts': [\n         *     { ids: [1, 2], setState }\n         *     { ids: [2, 3], setState, onSuccess }\n         *     { ids: [4, 5], setState }\n         *   ],\n         *   'comments': [\n         *     { ids: [345], setState, onFailure }\n         *   ]\n         * }\n         */\n        queriesToCall[resource] = queriesToCall[resource].concat({\n            ids: ids,\n            setState: setState,\n            onSuccess: options && options.onSuccess,\n            onFailure: options && options.onFailure,\n        });\n        callQueries(); // debounced by lodash\n    }, [JSON.stringify({ resource: resource, ids: ids, options: options }), dataProvider]); // eslint-disable-line react-hooks/exhaustive-deps\n    return state;\n};\n/**\n * Memoized selector for getting an array of resources based on an array of ids\n *\n * @see https://react-redux.js.org/next/api/hooks#using-memoizing-selectors\n */\nvar makeGetManySelector = function () {\n    return createSelector(function (state) { return state.admin.resources; }, function (_, resource) { return resource; }, function (_, __, ids) { return ids; }, function (resources, resource, ids) {\n        return resources[resource]\n            ? ids.map(function (id) { return resources[resource].data[id]; })\n            : ids.map(function (id) { return undefined; });\n    });\n};\n/**\n * Call the dataProvider once per resource\n */\nvar callQueries = debounce(function () {\n    var resources = Object.keys(queriesToCall);\n    resources.forEach(function (resource) {\n        var queries = __spreadArrays(queriesToCall[resource]); // cloning to avoid side effects\n        /**\n         * Extract ids from queries, aggregate and deduplicate them\n         *\n         * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n         */\n        var accumulatedIds = queries\n            .reduce(function (acc, _a) {\n            var ids = _a.ids;\n            return union(acc, ids);\n        }, []) // concat + unique\n            .filter(function (v) { return v != null && v !== ''; }); // remove null values\n        if (accumulatedIds.length === 0) {\n            // no need to call the data provider if all the ids are null\n            queries.forEach(function (_a) {\n                var ids = _a.ids, setState = _a.setState, onSuccess = _a.onSuccess;\n                setState({\n                    data: emptyArray,\n                    loading: false,\n                    loaded: true,\n                });\n                if (onSuccess) {\n                    onSuccess({ data: emptyArray });\n                }\n            });\n            return;\n        }\n        dataProvider\n            .getMany(resource, { ids: accumulatedIds }, DataProviderOptions)\n            .then(function (response) {\n            // Forces batching, see https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973\n            return ReactDOM.unstable_batchedUpdates(function () {\n                return queries.forEach(function (_a) {\n                    var ids = _a.ids, setState = _a.setState, onSuccess = _a.onSuccess;\n                    setState(function (prevState) { return (__assign(__assign({}, prevState), { error: null, loading: false, loaded: true })); });\n                    if (onSuccess) {\n                        var subData = ids.map(function (id) {\n                            return response.data.find(function (datum) { return datum.id == id; });\n                        } // eslint-disable-line eqeqeq\n                        );\n                        onSuccess({ data: subData });\n                    }\n                });\n            });\n        })\n            .catch(function (error) {\n            return ReactDOM.unstable_batchedUpdates(function () {\n                return queries.forEach(function (_a) {\n                    var setState = _a.setState, onFailure = _a.onFailure;\n                    setState({ error: error, loading: false, loaded: false });\n                    onFailure && onFailure(error);\n                });\n            });\n        });\n        delete queriesToCall[resource];\n    });\n});\nvar emptyArray = [];\nexport default useGetMany;\n"]},"metadata":{},"sourceType":"module"}