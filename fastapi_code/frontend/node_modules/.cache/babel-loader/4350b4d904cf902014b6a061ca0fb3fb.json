{"ast":null,"code":"import * as React from 'react';\nimport inflection from 'inflection';\nimport getValuesFromRecords from './getValuesFromRecords';\nimport InferredElement from './InferredElement';\nimport { isObject, valuesAreArray, valuesAreBoolean, valuesAreDate, valuesAreDateString, valuesAreHtml, valuesAreInteger, valuesAreNumeric, valuesAreObject, valuesAreString } from './assertions';\n\nvar DefaultComponent = function () {\n  return React.createElement(\"span\", null, \";\");\n};\n\nvar defaultType = {\n  type: DefaultComponent,\n  representation: function () {\n    return '<DefaultComponent />';\n  }\n};\nvar defaultTypes = {\n  array: defaultType,\n  boolean: defaultType,\n  date: defaultType,\n  email: defaultType,\n  id: defaultType,\n  number: defaultType,\n  reference: defaultType,\n  referenceArray: defaultType,\n  richText: defaultType,\n  string: defaultType,\n  url: defaultType\n};\n\nvar hasType = function (type, types) {\n  return typeof types[type] !== 'undefined';\n};\n/**\n * Guesses an element based on an array of values\n *\n * @example\n *     inferElementFromValues(\n *         'address',\n *         ['2 Baker Street', '1 Downing street'],\n *         { number: NumberField, string: StringField }\n *     );\n *     // new InferredElement(<StringField source=\"address\" />)\n *\n * Types are optional: if a type isn't provided, the function falls back\n * to the neareast type.\n *\n * @example\n *     inferElementFromValues(\n *         'content',\n *         ['<h1>Hello</h1>'],\n *         { string: StringField } // no richText type\n *     );\n *     // new InferredElement(<StringField source=\"content\" />)\n *\n * Types can be disabled by passing a falsy value.\n *\n * @example\n *     inferElementFromValues(\n *         'content',\n *         ['<h1>Hello</h1>'],\n *         { string: StringField, richText: false }\n *     );\n *     // null\n *\n * @param {string} name Property name, e.g. 'date_of_birth'\n * @param {any[]} values an array of values from which to determine the type, e.g. [12, 34.4, 43]\n * @param {Object} types A set of components indexed by type. The string type is the only required one\n *\n * @return InferredElement\n */\n\n\nvar inferElementFromValues = function (name, values, types) {\n  if (values === void 0) {\n    values = [];\n  }\n\n  if (types === void 0) {\n    types = defaultTypes;\n  }\n\n  if (name === 'id' && hasType('id', types)) {\n    return new InferredElement(types.id, {\n      source: name\n    });\n  }\n\n  if (name.substr(name.length - 3) === '_id' && hasType('reference', types)) {\n    var reference = inflection.pluralize(name.substr(0, name.length - 3));\n    return types.reference && new InferredElement(types.reference, {\n      source: name,\n      reference: reference\n    }, new InferredElement(types.referenceChild));\n  }\n\n  if (name.substr(name.length - 2) === 'Id' && hasType('reference', types)) {\n    var reference = inflection.pluralize(name.substr(0, name.length - 2));\n    return types.reference && new InferredElement(types.reference, {\n      source: name,\n      reference: reference\n    }, new InferredElement(types.referenceChild));\n  }\n\n  if (name.substr(name.length - 4) === '_ids' && hasType('referenceArray', types)) {\n    var reference = inflection.pluralize(name.substr(0, name.length - 4));\n    return types.referenceArray && new InferredElement(types.referenceArray, {\n      source: name,\n      reference: reference\n    }, new InferredElement(types.referenceArrayChild));\n  }\n\n  if (name.substr(name.length - 3) === 'Ids' && hasType('referenceArray', types)) {\n    var reference = inflection.pluralize(name.substr(0, name.length - 3));\n    return types.referenceArray && new InferredElement(types.referenceArray, {\n      source: name,\n      reference: reference\n    }, new InferredElement(types.referenceArrayChild));\n  }\n\n  if (values.length === 0) {\n    // FIXME introspect further using name\n    return new InferredElement(types.string, {\n      source: name\n    });\n  }\n\n  if (valuesAreArray(values)) {\n    if (isObject(values[0][0]) && hasType('array', types)) {\n      var leafValues_1 = getValuesFromRecords(values.reduce(function (acc, vals) {\n        return acc.concat(vals);\n      }, [])); // FIXME bad visual representation\n\n      return types.array && new InferredElement(types.array, {\n        source: name\n      }, Object.keys(leafValues_1).map(function (leafName) {\n        return inferElementFromValues(leafName, leafValues_1[leafName], types);\n      }));\n    } // FIXME introspect further\n\n\n    return new InferredElement(types.string, {\n      source: name\n    });\n  }\n\n  if (valuesAreBoolean(values) && hasType('boolean', types)) {\n    return new InferredElement(types.boolean, {\n      source: name\n    });\n  }\n\n  if (valuesAreDate(values) && hasType('date', types)) {\n    return new InferredElement(types.date, {\n      source: name\n    });\n  }\n\n  if (valuesAreString(values)) {\n    if (name === 'email' && hasType('email', types)) {\n      return new InferredElement(types.email, {\n        source: name\n      });\n    }\n\n    if (name === 'url' && hasType('url', types)) {\n      return new InferredElement(types.url, {\n        source: name\n      });\n    }\n\n    if (valuesAreDateString(values) && hasType('date', types)) {\n      return new InferredElement(types.date, {\n        source: name\n      });\n    }\n\n    if (valuesAreHtml(values) && hasType('richText', types)) {\n      return new InferredElement(types.richText, {\n        source: name\n      });\n    }\n\n    return new InferredElement(types.string, {\n      source: name\n    });\n  }\n\n  if ((valuesAreInteger(values) || valuesAreNumeric(values)) && hasType('number', types)) {\n    return new InferredElement(types.number, {\n      source: name\n    });\n  }\n\n  if (valuesAreObject(values)) {\n    // we need to go deeper\n    // Arbitrarily, choose the first prop of the first object\n    var propName_1 = Object.keys(values[0]).shift();\n    var leafValues = values.map(function (v) {\n      return v[propName_1];\n    });\n    return inferElementFromValues(name + \".\" + propName_1, leafValues, types);\n  }\n\n  return new InferredElement(types.string, {\n    source: name\n  });\n};\n\nexport default inferElementFromValues;","map":{"version":3,"sources":["/node_modules/ra-core/esm/inference/inferElementFromValues.js"],"names":["React","inflection","getValuesFromRecords","InferredElement","isObject","valuesAreArray","valuesAreBoolean","valuesAreDate","valuesAreDateString","valuesAreHtml","valuesAreInteger","valuesAreNumeric","valuesAreObject","valuesAreString","DefaultComponent","createElement","defaultType","type","representation","defaultTypes","array","boolean","date","email","id","number","reference","referenceArray","richText","string","url","hasType","types","inferElementFromValues","name","values","source","substr","length","pluralize","referenceChild","referenceArrayChild","leafValues_1","reduce","acc","vals","concat","Object","keys","map","leafName","propName_1","shift","leafValues","v"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,OAAOC,UAAP,MAAuB,YAAvB;AACA,OAAOC,oBAAP,MAAiC,wBAAjC;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,SAASC,QAAT,EAAmBC,cAAnB,EAAmCC,gBAAnC,EAAqDC,aAArD,EAAoEC,mBAApE,EAAyFC,aAAzF,EAAwGC,gBAAxG,EAA0HC,gBAA1H,EAA4IC,eAA5I,EAA6JC,eAA7J,QAAqL,cAArL;;AACA,IAAIC,gBAAgB,GAAG,YAAY;AAAE,SAAOd,KAAK,CAACe,aAAN,CAAoB,MAApB,EAA4B,IAA5B,EAAkC,GAAlC,CAAP;AAAgD,CAArF;;AACA,IAAIC,WAAW,GAAG;AACdC,EAAAA,IAAI,EAAEH,gBADQ;AAEdI,EAAAA,cAAc,EAAE,YAAY;AAAE,WAAO,sBAAP;AAAgC;AAFhD,CAAlB;AAIA,IAAIC,YAAY,GAAG;AACfC,EAAAA,KAAK,EAAEJ,WADQ;AAEfK,EAAAA,OAAO,EAAEL,WAFM;AAGfM,EAAAA,IAAI,EAAEN,WAHS;AAIfO,EAAAA,KAAK,EAAEP,WAJQ;AAKfQ,EAAAA,EAAE,EAAER,WALW;AAMfS,EAAAA,MAAM,EAAET,WANO;AAOfU,EAAAA,SAAS,EAAEV,WAPI;AAQfW,EAAAA,cAAc,EAAEX,WARD;AASfY,EAAAA,QAAQ,EAAEZ,WATK;AAUfa,EAAAA,MAAM,EAAEb,WAVO;AAWfc,EAAAA,GAAG,EAAEd;AAXU,CAAnB;;AAaA,IAAIe,OAAO,GAAG,UAAUd,IAAV,EAAgBe,KAAhB,EAAuB;AAAE,SAAO,OAAOA,KAAK,CAACf,IAAD,CAAZ,KAAuB,WAA9B;AAA4C,CAAnF;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA,IAAIgB,sBAAsB,GAAG,UAAUC,IAAV,EAAgBC,MAAhB,EAAwBH,KAAxB,EAA+B;AACxD,MAAIG,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,IAAAA,MAAM,GAAG,EAAT;AAAc;;AACvC,MAAIH,KAAK,KAAK,KAAK,CAAnB,EAAsB;AAAEA,IAAAA,KAAK,GAAGb,YAAR;AAAuB;;AAC/C,MAAIe,IAAI,KAAK,IAAT,IAAiBH,OAAO,CAAC,IAAD,EAAOC,KAAP,CAA5B,EAA2C;AACvC,WAAO,IAAI7B,eAAJ,CAAoB6B,KAAK,CAACR,EAA1B,EAA8B;AAAEY,MAAAA,MAAM,EAAEF;AAAV,KAA9B,CAAP;AACH;;AACD,MAAIA,IAAI,CAACG,MAAL,CAAYH,IAAI,CAACI,MAAL,GAAc,CAA1B,MAAiC,KAAjC,IAA0CP,OAAO,CAAC,WAAD,EAAcC,KAAd,CAArD,EAA2E;AACvE,QAAIN,SAAS,GAAGzB,UAAU,CAACsC,SAAX,CAAqBL,IAAI,CAACG,MAAL,CAAY,CAAZ,EAAeH,IAAI,CAACI,MAAL,GAAc,CAA7B,CAArB,CAAhB;AACA,WAAQN,KAAK,CAACN,SAAN,IACJ,IAAIvB,eAAJ,CAAoB6B,KAAK,CAACN,SAA1B,EAAqC;AACjCU,MAAAA,MAAM,EAAEF,IADyB;AAEjCR,MAAAA,SAAS,EAAEA;AAFsB,KAArC,EAGG,IAAIvB,eAAJ,CAAoB6B,KAAK,CAACQ,cAA1B,CAHH,CADJ;AAKH;;AACD,MAAIN,IAAI,CAACG,MAAL,CAAYH,IAAI,CAACI,MAAL,GAAc,CAA1B,MAAiC,IAAjC,IAAyCP,OAAO,CAAC,WAAD,EAAcC,KAAd,CAApD,EAA0E;AACtE,QAAIN,SAAS,GAAGzB,UAAU,CAACsC,SAAX,CAAqBL,IAAI,CAACG,MAAL,CAAY,CAAZ,EAAeH,IAAI,CAACI,MAAL,GAAc,CAA7B,CAArB,CAAhB;AACA,WAAQN,KAAK,CAACN,SAAN,IACJ,IAAIvB,eAAJ,CAAoB6B,KAAK,CAACN,SAA1B,EAAqC;AACjCU,MAAAA,MAAM,EAAEF,IADyB;AAEjCR,MAAAA,SAAS,EAAEA;AAFsB,KAArC,EAGG,IAAIvB,eAAJ,CAAoB6B,KAAK,CAACQ,cAA1B,CAHH,CADJ;AAKH;;AACD,MAAIN,IAAI,CAACG,MAAL,CAAYH,IAAI,CAACI,MAAL,GAAc,CAA1B,MAAiC,MAAjC,IACAP,OAAO,CAAC,gBAAD,EAAmBC,KAAnB,CADX,EACsC;AAClC,QAAIN,SAAS,GAAGzB,UAAU,CAACsC,SAAX,CAAqBL,IAAI,CAACG,MAAL,CAAY,CAAZ,EAAeH,IAAI,CAACI,MAAL,GAAc,CAA7B,CAArB,CAAhB;AACA,WAAQN,KAAK,CAACL,cAAN,IACJ,IAAIxB,eAAJ,CAAoB6B,KAAK,CAACL,cAA1B,EAA0C;AACtCS,MAAAA,MAAM,EAAEF,IAD8B;AAEtCR,MAAAA,SAAS,EAAEA;AAF2B,KAA1C,EAGG,IAAIvB,eAAJ,CAAoB6B,KAAK,CAACS,mBAA1B,CAHH,CADJ;AAKH;;AACD,MAAIP,IAAI,CAACG,MAAL,CAAYH,IAAI,CAACI,MAAL,GAAc,CAA1B,MAAiC,KAAjC,IACAP,OAAO,CAAC,gBAAD,EAAmBC,KAAnB,CADX,EACsC;AAClC,QAAIN,SAAS,GAAGzB,UAAU,CAACsC,SAAX,CAAqBL,IAAI,CAACG,MAAL,CAAY,CAAZ,EAAeH,IAAI,CAACI,MAAL,GAAc,CAA7B,CAArB,CAAhB;AACA,WAAQN,KAAK,CAACL,cAAN,IACJ,IAAIxB,eAAJ,CAAoB6B,KAAK,CAACL,cAA1B,EAA0C;AACtCS,MAAAA,MAAM,EAAEF,IAD8B;AAEtCR,MAAAA,SAAS,EAAEA;AAF2B,KAA1C,EAGG,IAAIvB,eAAJ,CAAoB6B,KAAK,CAACS,mBAA1B,CAHH,CADJ;AAKH;;AACD,MAAIN,MAAM,CAACG,MAAP,KAAkB,CAAtB,EAAyB;AACrB;AACA,WAAO,IAAInC,eAAJ,CAAoB6B,KAAK,CAACH,MAA1B,EAAkC;AAAEO,MAAAA,MAAM,EAAEF;AAAV,KAAlC,CAAP;AACH;;AACD,MAAI7B,cAAc,CAAC8B,MAAD,CAAlB,EAA4B;AACxB,QAAI/B,QAAQ,CAAC+B,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,CAAD,CAAR,IAA0BJ,OAAO,CAAC,OAAD,EAAUC,KAAV,CAArC,EAAuD;AACnD,UAAIU,YAAY,GAAGxC,oBAAoB,CAACiC,MAAM,CAACQ,MAAP,CAAc,UAAUC,GAAV,EAAeC,IAAf,EAAqB;AAAE,eAAOD,GAAG,CAACE,MAAJ,CAAWD,IAAX,CAAP;AAA0B,OAA/D,EAAiE,EAAjE,CAAD,CAAvC,CADmD,CAEnD;;AACA,aAAQb,KAAK,CAACZ,KAAN,IACJ,IAAIjB,eAAJ,CAAoB6B,KAAK,CAACZ,KAA1B,EAAiC;AAC7BgB,QAAAA,MAAM,EAAEF;AADqB,OAAjC,EAEGa,MAAM,CAACC,IAAP,CAAYN,YAAZ,EAA0BO,GAA1B,CAA8B,UAAUC,QAAV,EAAoB;AACjD,eAAOjB,sBAAsB,CAACiB,QAAD,EAAWR,YAAY,CAACQ,QAAD,CAAvB,EAAmClB,KAAnC,CAA7B;AACH,OAFE,CAFH,CADJ;AAMH,KAVuB,CAWxB;;;AACA,WAAO,IAAI7B,eAAJ,CAAoB6B,KAAK,CAACH,MAA1B,EAAkC;AAAEO,MAAAA,MAAM,EAAEF;AAAV,KAAlC,CAAP;AACH;;AACD,MAAI5B,gBAAgB,CAAC6B,MAAD,CAAhB,IAA4BJ,OAAO,CAAC,SAAD,EAAYC,KAAZ,CAAvC,EAA2D;AACvD,WAAO,IAAI7B,eAAJ,CAAoB6B,KAAK,CAACX,OAA1B,EAAmC;AAAEe,MAAAA,MAAM,EAAEF;AAAV,KAAnC,CAAP;AACH;;AACD,MAAI3B,aAAa,CAAC4B,MAAD,CAAb,IAAyBJ,OAAO,CAAC,MAAD,EAASC,KAAT,CAApC,EAAqD;AACjD,WAAO,IAAI7B,eAAJ,CAAoB6B,KAAK,CAACV,IAA1B,EAAgC;AAAEc,MAAAA,MAAM,EAAEF;AAAV,KAAhC,CAAP;AACH;;AACD,MAAIrB,eAAe,CAACsB,MAAD,CAAnB,EAA6B;AACzB,QAAID,IAAI,KAAK,OAAT,IAAoBH,OAAO,CAAC,OAAD,EAAUC,KAAV,CAA/B,EAAiD;AAC7C,aAAO,IAAI7B,eAAJ,CAAoB6B,KAAK,CAACT,KAA1B,EAAiC;AAAEa,QAAAA,MAAM,EAAEF;AAAV,OAAjC,CAAP;AACH;;AACD,QAAIA,IAAI,KAAK,KAAT,IAAkBH,OAAO,CAAC,KAAD,EAAQC,KAAR,CAA7B,EAA6C;AACzC,aAAO,IAAI7B,eAAJ,CAAoB6B,KAAK,CAACF,GAA1B,EAA+B;AAAEM,QAAAA,MAAM,EAAEF;AAAV,OAA/B,CAAP;AACH;;AACD,QAAI1B,mBAAmB,CAAC2B,MAAD,CAAnB,IAA+BJ,OAAO,CAAC,MAAD,EAASC,KAAT,CAA1C,EAA2D;AACvD,aAAO,IAAI7B,eAAJ,CAAoB6B,KAAK,CAACV,IAA1B,EAAgC;AAAEc,QAAAA,MAAM,EAAEF;AAAV,OAAhC,CAAP;AACH;;AACD,QAAIzB,aAAa,CAAC0B,MAAD,CAAb,IAAyBJ,OAAO,CAAC,UAAD,EAAaC,KAAb,CAApC,EAAyD;AACrD,aAAO,IAAI7B,eAAJ,CAAoB6B,KAAK,CAACJ,QAA1B,EAAoC;AAAEQ,QAAAA,MAAM,EAAEF;AAAV,OAApC,CAAP;AACH;;AACD,WAAO,IAAI/B,eAAJ,CAAoB6B,KAAK,CAACH,MAA1B,EAAkC;AAAEO,MAAAA,MAAM,EAAEF;AAAV,KAAlC,CAAP;AACH;;AACD,MAAI,CAACxB,gBAAgB,CAACyB,MAAD,CAAhB,IAA4BxB,gBAAgB,CAACwB,MAAD,CAA7C,KACAJ,OAAO,CAAC,QAAD,EAAWC,KAAX,CADX,EAC8B;AAC1B,WAAO,IAAI7B,eAAJ,CAAoB6B,KAAK,CAACP,MAA1B,EAAkC;AAAEW,MAAAA,MAAM,EAAEF;AAAV,KAAlC,CAAP;AACH;;AACD,MAAItB,eAAe,CAACuB,MAAD,CAAnB,EAA6B;AACzB;AACA;AACA,QAAIgB,UAAU,GAAGJ,MAAM,CAACC,IAAP,CAAYb,MAAM,CAAC,CAAD,CAAlB,EAAuBiB,KAAvB,EAAjB;AACA,QAAIC,UAAU,GAAGlB,MAAM,CAACc,GAAP,CAAW,UAAUK,CAAV,EAAa;AAAE,aAAOA,CAAC,CAACH,UAAD,CAAR;AAAuB,KAAjD,CAAjB;AACA,WAAOlB,sBAAsB,CAACC,IAAI,GAAG,GAAP,GAAaiB,UAAd,EAA0BE,UAA1B,EAAsCrB,KAAtC,CAA7B;AACH;;AACD,SAAO,IAAI7B,eAAJ,CAAoB6B,KAAK,CAACH,MAA1B,EAAkC;AAAEO,IAAAA,MAAM,EAAEF;AAAV,GAAlC,CAAP;AACH,CA3FD;;AA4FA,eAAeD,sBAAf","sourcesContent":["import * as React from 'react';\nimport inflection from 'inflection';\nimport getValuesFromRecords from './getValuesFromRecords';\nimport InferredElement from './InferredElement';\nimport { isObject, valuesAreArray, valuesAreBoolean, valuesAreDate, valuesAreDateString, valuesAreHtml, valuesAreInteger, valuesAreNumeric, valuesAreObject, valuesAreString, } from './assertions';\nvar DefaultComponent = function () { return React.createElement(\"span\", null, \";\"); };\nvar defaultType = {\n    type: DefaultComponent,\n    representation: function () { return '<DefaultComponent />'; },\n};\nvar defaultTypes = {\n    array: defaultType,\n    boolean: defaultType,\n    date: defaultType,\n    email: defaultType,\n    id: defaultType,\n    number: defaultType,\n    reference: defaultType,\n    referenceArray: defaultType,\n    richText: defaultType,\n    string: defaultType,\n    url: defaultType,\n};\nvar hasType = function (type, types) { return typeof types[type] !== 'undefined'; };\n/**\n * Guesses an element based on an array of values\n *\n * @example\n *     inferElementFromValues(\n *         'address',\n *         ['2 Baker Street', '1 Downing street'],\n *         { number: NumberField, string: StringField }\n *     );\n *     // new InferredElement(<StringField source=\"address\" />)\n *\n * Types are optional: if a type isn't provided, the function falls back\n * to the neareast type.\n *\n * @example\n *     inferElementFromValues(\n *         'content',\n *         ['<h1>Hello</h1>'],\n *         { string: StringField } // no richText type\n *     );\n *     // new InferredElement(<StringField source=\"content\" />)\n *\n * Types can be disabled by passing a falsy value.\n *\n * @example\n *     inferElementFromValues(\n *         'content',\n *         ['<h1>Hello</h1>'],\n *         { string: StringField, richText: false }\n *     );\n *     // null\n *\n * @param {string} name Property name, e.g. 'date_of_birth'\n * @param {any[]} values an array of values from which to determine the type, e.g. [12, 34.4, 43]\n * @param {Object} types A set of components indexed by type. The string type is the only required one\n *\n * @return InferredElement\n */\nvar inferElementFromValues = function (name, values, types) {\n    if (values === void 0) { values = []; }\n    if (types === void 0) { types = defaultTypes; }\n    if (name === 'id' && hasType('id', types)) {\n        return new InferredElement(types.id, { source: name });\n    }\n    if (name.substr(name.length - 3) === '_id' && hasType('reference', types)) {\n        var reference = inflection.pluralize(name.substr(0, name.length - 3));\n        return (types.reference &&\n            new InferredElement(types.reference, {\n                source: name,\n                reference: reference,\n            }, new InferredElement(types.referenceChild)));\n    }\n    if (name.substr(name.length - 2) === 'Id' && hasType('reference', types)) {\n        var reference = inflection.pluralize(name.substr(0, name.length - 2));\n        return (types.reference &&\n            new InferredElement(types.reference, {\n                source: name,\n                reference: reference,\n            }, new InferredElement(types.referenceChild)));\n    }\n    if (name.substr(name.length - 4) === '_ids' &&\n        hasType('referenceArray', types)) {\n        var reference = inflection.pluralize(name.substr(0, name.length - 4));\n        return (types.referenceArray &&\n            new InferredElement(types.referenceArray, {\n                source: name,\n                reference: reference,\n            }, new InferredElement(types.referenceArrayChild)));\n    }\n    if (name.substr(name.length - 3) === 'Ids' &&\n        hasType('referenceArray', types)) {\n        var reference = inflection.pluralize(name.substr(0, name.length - 3));\n        return (types.referenceArray &&\n            new InferredElement(types.referenceArray, {\n                source: name,\n                reference: reference,\n            }, new InferredElement(types.referenceArrayChild)));\n    }\n    if (values.length === 0) {\n        // FIXME introspect further using name\n        return new InferredElement(types.string, { source: name });\n    }\n    if (valuesAreArray(values)) {\n        if (isObject(values[0][0]) && hasType('array', types)) {\n            var leafValues_1 = getValuesFromRecords(values.reduce(function (acc, vals) { return acc.concat(vals); }, []));\n            // FIXME bad visual representation\n            return (types.array &&\n                new InferredElement(types.array, {\n                    source: name,\n                }, Object.keys(leafValues_1).map(function (leafName) {\n                    return inferElementFromValues(leafName, leafValues_1[leafName], types);\n                })));\n        }\n        // FIXME introspect further\n        return new InferredElement(types.string, { source: name });\n    }\n    if (valuesAreBoolean(values) && hasType('boolean', types)) {\n        return new InferredElement(types.boolean, { source: name });\n    }\n    if (valuesAreDate(values) && hasType('date', types)) {\n        return new InferredElement(types.date, { source: name });\n    }\n    if (valuesAreString(values)) {\n        if (name === 'email' && hasType('email', types)) {\n            return new InferredElement(types.email, { source: name });\n        }\n        if (name === 'url' && hasType('url', types)) {\n            return new InferredElement(types.url, { source: name });\n        }\n        if (valuesAreDateString(values) && hasType('date', types)) {\n            return new InferredElement(types.date, { source: name });\n        }\n        if (valuesAreHtml(values) && hasType('richText', types)) {\n            return new InferredElement(types.richText, { source: name });\n        }\n        return new InferredElement(types.string, { source: name });\n    }\n    if ((valuesAreInteger(values) || valuesAreNumeric(values)) &&\n        hasType('number', types)) {\n        return new InferredElement(types.number, { source: name });\n    }\n    if (valuesAreObject(values)) {\n        // we need to go deeper\n        // Arbitrarily, choose the first prop of the first object\n        var propName_1 = Object.keys(values[0]).shift();\n        var leafValues = values.map(function (v) { return v[propName_1]; });\n        return inferElementFromValues(name + \".\" + propName_1, leafValues, types);\n    }\n    return new InferredElement(types.string, { source: name });\n};\nexport default inferElementFromValues;\n"]},"metadata":{},"sourceType":"module"}